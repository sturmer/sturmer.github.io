<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45596498-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>Implement std::multiset | Gianluca Ciccarelli</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="In this post, I talk about the std::multiset and about some design decisions I needed when trying to implement it. The full implementation is on GitHub.">
<meta property="og:type" content="article">
<meta property="og:title" content="Implement std::multiset">
<meta property="og:url" content="https://www.gergel.im/2018/07/12/implement-std-multiset/index.html">
<meta property="og:site_name" content="Gianluca Ciccarelli">
<meta property="og:description" content="In this post, I talk about the std::multiset and about some design decisions I needed when trying to implement it. The full implementation is on GitHub.">
<meta property="og:locale">
<meta property="article:published_time" content="2018-07-12T11:40:09.000Z">
<meta property="article:modified_time" content="2020-08-15T09:14:02.646Z">
<meta property="article:author" content="Gianluca Ciccarelli">
<meta property="article:tag" content="stl">
<meta property="article:tag" content="multiset">
<meta property="article:tag" content="cpp">
<meta name="twitter:card" content="summary">
<meta name="twitter:creator" content="@increatore">
  
    <link rel="alternate" href="/atom.xml" title="Gianluca Ciccarelli" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Gianluca Ciccarelli</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/index.html">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/now.html">Now</a>
        
          <a class="main-nav-link" href="/blog">Blog</a>
        
          <a class="main-nav-link" href="/fiction.html">Fiction</a>
        
          <a class="main-nav-link" href="/reads.html">Reads</a>
        
          <a class="main-nav-link" href="/software.html">Software</a>
        
          <a class="main-nav-link" href="/about-site.html">Website</a>
        
          <a class="main-nav-link" target="_blank" rel="noopener" href="//github.com/sturmer">GitHub</a>
        
          <a class="main-nav-link" href="/about-me.html">Me</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://www.gergel.im"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-implement-std-multiset" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/implement-std-multiset/" class="article-date">
  <!-- Use `hideDate: true` in a .md file to hide the date -->
  
  <time datetime="2018-07-12T11:40:09.000Z" itemprop="datePublished">2018-07-12</time>
  
</a>

    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Implement std::multiset
    </h1>
  

        
          [821 words]
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In this post, I talk about the <code>std::multiset</code> and about some design decisions I needed when trying to implement it. The full implementation is on <a target="_blank" rel="noopener" href="https://github.com/sturmer/reference-implementations-cpp/tree/master/DataStructures/multiset">GitHub</a>.</p>
<a id="more"></a>

<h1 id="Multisets-and-multimaps"><a href="#Multisets-and-multimaps" class="headerlink" title="Multisets and multimaps"></a>Multisets and multimaps</h1><p>There are a few data structures in the standard library that I never use. In some cases, it’s because I never had the right use case no my hands, in others (embarrassingly enough) because I am too lazy to read up about one that I’m not already familiar with. But lately I’ve found myself needing something to solve a problem, and I discovered that I could get some great help by just using a data structure I’d never heard of: the <code>std::multiset</code> (or its cousin, the <code>std::multimap</code>).</p>
<p>I had read about it before. On the surface, it is just like a <code>std::set</code>, but it let you store the keys multiple times. Why on Earth would you need that, and in particular, which cases are not served as well by just the <code>std::set</code>?</p>
<p>There’s something interesting, however, about this structure: It keeps its keys sorted. Consider the following situation: You want to store the nodes of a binary tree by level (root being at level 1, leaves at <code>level O(log(N)) + 1</code> if we have <code>N</code> nodes and a balanced tree). Then you want to print the sum of the values of the nodes at each level, sorted by (ascending) level.</p>
<p>You could scan the tree and use a map level-to-nodes to accomplish this. However, you know that a <code>std::map</code> would not keep the order of the keys.</p>
<p>A better way to do it is by using a multimap! You’d do something like:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> <span class="keyword">level_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLevelSums</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num_levels)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multimap</span>&lt;<span class="keyword">level_t</span>, node&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store each node using the level as a key. Note that we have multiple</span></span><br><span class="line">    <span class="comment">// keys with the same value.</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num_levels; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> range = m.equal_range(i)</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.first; it != range.second; ++it) &#123;</span><br><span class="line">            sum += it-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Implementing-a-multiset"><a href="#Implementing-a-multiset" class="headerlink" title="Implementing a multiset"></a>Implementing a multiset</h1><p>The requirements on the basic operations of a multiset, expressed in terms of time complexity, are the following:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(log(size)):</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> Key&amp; t)</span></span>;  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> Key&amp; t)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the number of elements with key `key`.</span></span><br><span class="line"><span class="comment">// O(log(size of the container)) plus linear in the number of the elements</span></span><br><span class="line"><span class="comment">// found.</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Removes all elements with the key equivalent to key. Return number of</span></span><br><span class="line"><span class="comment">// elements erased. O(log(c.size()) + c.count(k)).</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp; key)</span></span>;</span><br></pre></td></tr></table></figure>

<p>We see that the insertion and search are not constant like they would if using a hash, but logarithmic. The <code>count</code> operation reveals how many elements having the same key are in the multiset.</p>
<p>One way of implementing this is by using a <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search tree</a>, where each node contains a <code>vector&lt;Key&gt;</code>. We would then have something like:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiset</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> node&lt;Key&gt; BinarySearchTree;</span><br><span class="line">    BinarySearchTree backend_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Back-end-the-node"><a href="#Back-end-the-node" class="headerlink" title="Back-end: the node"></a>Back-end: the <code>node</code></h2><p>The strategy I used was to just implement a BST with the right data and then forwarding the operations to the node. You all know what a node/BST looks like, so I’ll just write a few words about bizarre operations I implemented. Here’s the complete interface of the node/BST structure (I decided to use the node as a recursive definition of a BST):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A node is a tree.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Key&gt;* data_;  <span class="comment">// never null if the object exists.    // <span class="doctag">TODO:</span></span></span><br><span class="line">                         <span class="comment">// use optional&lt;vector&lt;Key&gt;&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getsize</span><span class="params">(<span class="keyword">unsigned</span>&amp; cnt)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">vectorize</span><span class="params">(<span class="built_in">vector</span>&lt;Key*&gt;&amp; v)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    std::pair&lt;node&lt;Key&gt;*, is_left_child_t&gt; findParent(const node&lt;Key&gt;* n);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    node&lt;Key&gt;* left_;</span><br><span class="line">    node&lt;Key&gt;* right_;</span><br><span class="line"></span><br><span class="line">    node() : data_(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;Key&gt;), left_(<span class="literal">nullptr</span>), right_(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    node(<span class="keyword">const</span> Key&amp; k)</span><br><span class="line">        : data_(<span class="keyword">new</span> <span class="built_in">vector</span>&lt;Key&gt;), left_(<span class="literal">nullptr</span>), right_(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        data_-&gt;push_back(k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~node();</span><br><span class="line"></span><br><span class="line">    <span class="function">Key <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span></span>;</span><br><span class="line">    <span class="function">node&lt;Key&gt;* <span class="title">find</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">nodesize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">node&lt;Key&gt;* <span class="title">findSuccessor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> Key&amp; k)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;Key*&gt; <span class="title">vectorize</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>vectorize</code>: this method transforms the multiset into a vector of the keys, without repeating them. It is useful for the implementation of the <code>iterator</code>. I’ll talk about the iterators in a separate section.</li>
<li><code>nodesize</code>: The number of items associated with a single <code>Key</code>. <code>size</code> just returns the number of stored keys.</li>
<li><code>findParent</code>: I don’t store the node’s parent in my implementation. It would have simplified things, but it’s a trade-off between space and complexity, or space and time (I need to find the parent when I need it, which takes <code>O(log(N))</code> time, so I can spare a pointer in each node, that would allow me to find the parent in <code>O(1)</code> if I know the address of the node in question. Oh well.)</li>
</ul>
<h3 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h3><p>The iterator on a multiset should offer what you usually expect from such a class: a <code>begin()</code> and an <code>end()</code> method, plus some pre- and post-increment or another equivalent of a <code>next()</code> method to go to the next node. To do it, I’ve used a <code>vector</code> of Key pointers and an index into it. When I build an iterator from a node, I can process the sub-tree starting at that node. Since the multiset contains only Key values, my iterator needs to hide the fact that I’m using a tree in the back-end, which is why the de-referencing operator returns a Key itself, and not a node.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;Key*&gt; to_process_;</span><br><span class="line">        <span class="keyword">int</span> cur_;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">public</span>:</span><br><span class="line">        iterator(node&lt;Key&gt;* n) : cur_(n ? <span class="number">0</span> : <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n) &#123;</span><br><span class="line">                to_process_ = n-&gt;vectorize();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pre-increment:</span></span><br><span class="line">        iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_ == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++cur_;</span><br><span class="line">            <span class="keyword">if</span> (cur_ == to_process_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                cur_ = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Key&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_ == <span class="number">-1</span> || cur_ == to_process_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> OutOfRange();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *to_process_[cur_];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_ == <span class="number">-1</span> &amp;&amp; it.cur_ == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it.cur_ == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur_ &gt;= to_process_.<span class="built_in">size</span>() || cur_ == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (to_process_[cur_] &amp;&amp; it.to_process_[cur_]) &#123;</span><br><span class="line">                <span class="keyword">return</span> *(to_process_[cur_]) == *(it.to_process_[cur_]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !<span class="keyword">operator</span>==(it); &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h1><p>A few considerations:</p>
<p>Needless to say, there’s a lot of room for improvement. It took me a few days to implement this basic version, and I realize now that it might not necessarily do what I wanted to do (for instance, the iterator doesn’t allow you to iterate over all the keys, like the <code>std::multiset</code> does, but only on the non-repeating ones).</p>
<p>Once more, I see that implementing on paper to have a full vision of what you’re going to do is of paramount importance: The farther down the way to the full implementation you spot errors, the longer the corrections take, and the more they can impact other areas which you have lost track of in the meanwhile. With more experience, you can usually keep a bigger plan in your head.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://www.gergel.im/2018/07/12/implement-std-multiset/" data-id="ckjifppby0014huvn87c69br2" class="article-share-link">Share</a>
      
        <a href="https://www.gergel.im/2018/07/12/implement-std-multiset/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/" rel="tag">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/multiset/" rel="tag">multiset</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/stl/" rel="tag">stl</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/07/20/implemented-a-red-black-tree-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          I implemented a Red-Black tree (part 1)
        
      </div>
    </a>
  
  
    <a href="/2018/06/13/start-ts-project-on-node/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Start a TypeScript project on Node.js</div>
    </a>
  
</nav>

  
</article>


<section id="comments">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Gianluca Ciccarelli<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/index.html" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/now.html" class="mobile-nav-link">Now</a>
  
    <a href="/blog" class="mobile-nav-link">Blog</a>
  
    <a href="/fiction.html" class="mobile-nav-link">Fiction</a>
  
    <a href="/reads.html" class="mobile-nav-link">Reads</a>
  
    <a href="/software.html" class="mobile-nav-link">Software</a>
  
    <a href="/about-site.html" class="mobile-nav-link">Website</a>
  
    <a target="_blank" rel="noopener" href="//github.com/sturmer" class="mobile-nav-link">GitHub</a>
  
    <a href="/about-me.html" class="mobile-nav-link">Me</a>
  
</nav>
    
<script>
  var disqus_shortname = 'www-gergel-im-blog';
  
  var disqus_url = 'https://www.gergel.im/2018/07/12/implement-std-multiset/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>