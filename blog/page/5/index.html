<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="../../../static/style.css">
<title>Blog â€” Gergelim</title>
<body>
  <header>
    <h1>Gergelim</h1>
    <nav>
      <ul class="nav navbar-nav">
        <li><a href="../../../">Welcome</a></li>
        
          <li class="active"><a href="../../">Blog</a></li>
        
          <li><a href="../../../projects/">Projects</a></li>
        
          <li><a href="../../../about/">About</a></li>
        
      </ul>
    </nav>
  </header>
  <div class="page">
    
  
    
  <div class="blog-post">
  
    <h2><a href="../../time-in-c/">Time in C++</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2014-01-20
  </p>
  <h3>Using time: the chrono header</h3>
<p>Until before the introduction of the <code>chrono</code> library in the STL with the C++11 standard, we were forced to deal with time in a couple of ways, notably using Boost or using some wrapper around the <code>time.h</code> library header, from C.</p>
<!-- more -->

<p>With the latest standard (soon to be replaced by C++14!), most of the functionality of the Boost DateTime library has been ported to the STL, with some simplifications that are most welcome.</p>
<p>The <code>chrono</code> library header is based on a few concepts. The first is the concept of clock: the clock measures time. Three clocks are made available on the system, but for illustration purposes, their distinction is unimportant (we will see it later). The second concept is that of <em>duration</em>: it is intuitively an amount of time. The third is the concept of <code>time_point</code>: it is defined as a duration calculated with respect to an <em>epoch</em>, which in turn is the beginning of time.</p>
<h3>Duration</h3>
<p>The simplest concept is the duration. In C++, it is defined as depending on two types, the numeric type we want to use to represent it, and the number of seconds per tick. The tick determines the resolution of the duration type: if we imagine a clock to tick once each tick seconds, then for example we can easily see that a duration in minutes can be expressed as:</p>
<div class="hll"><pre><span></span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">60</span><span class="o">&gt;&gt;</span> <span class="n">mins</span><span class="p">;</span>
</pre></div>
<p>This simply means: my duration is represented as an <code>int</code>, and a duration of 3 would mean <em>three times 60 seconds</em>, or 3 minutes. <code>std::ratio</code> is a useful C++ type that expresses divisions. It is a compile-time constant, and when only one number is specified, then it's the numerator, and the denominator is 1. For example,</p>
<div class="hll"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span>
</pre></div>
<p>is a convenient way to write the fraction 1/10.</p>
<p>The STL predefines some convenient durations, like <code>minutes</code> (defined as above), <code>seconds</code>, and the likes. Durations can be easily converted between each other, so if we want to convert a duration in minutes into a duration in seconds, we would write:</p>
<div class="hll"><pre><span></span><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">TICKS</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
<span class="n">duration</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ratio</span><span class="o">&lt;</span><span class="mi">60</span><span class="o">&gt;&gt;</span> <span class="n">mins</span><span class="p">(</span><span class="n">TICKS</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mins</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; minutes = &quot;</span> <span class="o">&lt;&lt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="n">mins</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
<p>for which the output would be:</p>
<pre>
20 minutes = 1200 seconds
</pre><p>Notice the use of the method <code>count()</code>, that expresses the number of ticks in the duration.</p>
<p>Durations can easily be used with operators:</p>
<div class="hll"><pre><span></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">minutes</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">hours</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hours</span> <span class="n">d0</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">minutes</span> <span class="n">d1</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
    <span class="n">seconds</span> <span class="n">d2</span><span class="p">(</span><span class="mi">44</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">seconds</span><span class="p">(</span><span class="n">d0</span> <span class="o">+</span> <span class="n">d1</span> <span class="o">+</span> <span class="n">d2</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;2h32&#39;44</span><span class="se">\&quot;</span><span class="s"> = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>would generate an output of:</p>
<pre>
2h32'44" = 9164"
</pre><h3>Time points and clocks</h3>
<p>As said, time points are fundamentally a duration with respect to an epoch. A clock, on the other hand, is a structure containing (among the other things) a <code>time_point</code> and a <code>duration</code>. The following code would work on a system with an implementation of the I/O manipulator <code>put_time</code>:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="kt">time_t</span> <span class="n">as_tt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tm</span><span class="o">*</span> <span class="n">c_time</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as_tt</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">put_time</span><span class="p">(</span><span class="n">c_time</span><span class="p">,</span> <span class="s">&quot;%H:%M:%S&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Unfortunately, my system is not such system. This required me, in order to produce the same result, to hack with the C API provided by <code>chrono</code>:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="kt">time_t</span> <span class="n">as_tt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tm</span><span class="o">*</span> <span class="n">c_time</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">as_tt</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">strftime</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%Y/%m/%d@%H:%M:%S&quot;</span><span class="p">,</span> <span class="n">c_time</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>This generates the following output:</p>
<pre>
2014/01/20@19:35:13
</pre><p>Time points are easy to use together with clocks in order to compute some date in the future or in the past. For example, consider if we want to add one week to today, and know what day it is. We can easily do that with the following code:</p>
<div class="hll"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;ctime&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">time_point</span> <span class="n">now</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="n">time_point</span> <span class="n">tp_later</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span>
        <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">hours</span><span class="p">(</span><span class="mi">7</span><span class="o">*</span><span class="mi">24</span><span class="p">);</span>

    <span class="kt">time_t</span> <span class="n">later_as_tt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">tp_later</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tm</span><span class="o">*</span> <span class="n">c_time</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">later_as_tt</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">strftime</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">&quot;%Y/%m/%d&quot;</span><span class="p">,</span> <span class="n">c_time</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">buf</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3>Pitfalls</h3>
<p>When dealing with durations and times, there are some pitfalls. The nice conversion operation we have seen with durations fails miserably at compile time, if the type used to represent the duration itself might lose precision when converted: for example, if you construct a duration in minutes represented with <code>int</code>, and use a duration in hours to initialize it, the compiler would bark because it would lose information during the construction process.</p>
<p>Other common issues come from the loss of precision in the clocks due to the machine not being able to have too precise time resolutions, or due to OSes that fail to update the clock faster than the resolution itself (example: resolution of 1 ms, and OS updating the clock every 10 ms).</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../stl-algorithms-part-4/">STL Algorithms, part 4</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2014-01-14
  </p>
  <ul>
<li><a href="../../stl-algorithms-part-1/">Part 1</a></li>
<li><a href="../../stl-algorithms-part-2/">Part 2</a></li>
<li><a href="../../stl-algorithms-part-3/">Part 3</a></li>
<li><a href="../../stl-algorithms-part-4/">Part 4</a></li>
<li><a href="../../stl-algorithms-part-5/">Part 5</a></li>
</ul>
<p>We have seen some examples of usage of the <code>find</code> algorithm, with its variants <code>find_if</code> and  <code>find_if_not</code>. In this installment, we are going to see other variants of finding algorithms, plus another algorithm useful when counting items in a sequence, <code>count</code>. Remember that we are still in the realm of non-modifying sequence algorithms (but see the discussion about <code>for_each</code> <a href="../../2013/12/30/stl-algorithms-part-2/" title="STL Algorithms, part 2">here</a>).</p>
<!-- more -->

<h3><code>find_first</code>: Find first occurrence of any element taken from a set</h3>
<p>This algorithm is useful when we are looking for one element of a set. Consider a <code>std::string</code>, which is also a container, and the problem of finding any vowel in such a string. We could go like the following:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">set</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">vowels</span><span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;u&#39;</span><span class="p">,</span> <span class="sc">&#39;y&#39;</span><span class="p">};</span>   <span class="c1">// is y a vowel?</span>
    <span class="n">string</span> <span class="n">haystack</span><span class="p">{</span><span class="s">&quot;haystack&quot;</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_first_of</span><span class="p">(</span><span class="n">haystack</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">haystack</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="n">vowels</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vowels</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">haystack</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">find_first_of</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">haystack</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="n">vowels</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vowels</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>This small program will print the sequence of vowels in the word <em>haystack</em>. I am not sure that <em>y</em> is a vowel (actually I doubt), but I can invoke the exemplification\'s excuse. The output is:</p>
<pre>
    a
    y
    a
</pre><p>This algorithm can have a significant overhead because it has quadratic complexity (its execution time grows as the multiplication of the length of the two sequences). It prototype is:</p>
<div class="hll"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">ForwardIterator</span><span class="o">&gt;</span>
<span class="n">InputIterator</span>
<span class="n">find_first_of</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first1</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last1</span><span class="p">,</span>
  <span class="n">ForwardIterator</span> <span class="n">first2</span><span class="p">,</span> <span class="n">ForwardIterator</span> <span class="n">last2</span><span class="p">);</span>
</pre></div>
<p>There is also a similar version where we can add a predicate, this way stating that we are looking for any of the elements in the second sequence for which the predicate is satisfied.</p>
<h3><code>find_end</code>: Find subsequences</h3>
<p>This algorithm has a deceptive name. It finds the subsequence in a sequence, returning the iterator to the first character of such sequence, or returning the last element of the first sequence if no such subsequence is found. The name comes from the fact that such subsequence is the rightmost, in case it occurred more than once. Consider the following example:</p>
<div class="hll"><pre><span></span><span class="n">string</span> <span class="n">subseq</span><span class="p">{</span><span class="s">&quot;lazy&quot;</span><span class="p">};</span>
<span class="n">string</span> <span class="n">seq</span><span class="p">{</span><span class="s">&quot;the quick brown fox jumped over the lazy dog, &quot;</span>
    <span class="s">&quot;but the lazy dog woke up&quot;</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_end</span><span class="p">(</span><span class="n">seq</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">seq</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="n">subseq</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">subseq</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">res</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">seq</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Result: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
<p>Its output is simply:</p>
<pre>
Result: lazy dog woke up
</pre><p>Also this algorithm has a variant where we can specify a predicate to be satisfied for each element matched.</p>
<h3><code>adjacent_find</code>: Find consecutive elements</h3>
<p>Suppose now that you want to find whether there are repeated elements in a string. The <code>adjacent_find</code> algorithm does just that, returning an iterator to the first element that is followed by itself at least once. Also this algorithms comes with a variation allowing to specify a predicate:</p>
<div class="hll"><pre><span></span><span class="n">string</span> <span class="n">seq</span><span class="p">{</span><span class="s">&quot;arbababbbbbbbbbccc&quot;</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">adjacent_find</span><span class="p">(</span><span class="n">seq</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">seq</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">char</span> <span class="n">c1</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c2</span><span class="p">)</span>
        <span class="p">{</span> <span class="k">return</span> <span class="n">c1</span> <span class="o">!=</span> <span class="sc">&#39;r&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">c2</span> <span class="o">==</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span> <span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">res</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">seq</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Sequence: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">seq</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Result:      &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
<p>The outcome of this algorithm is the following: for each letter and its immediate successor, the predicate should be satisfied. This holds true for the first time when we arrive at the fourth letter, so the outcome is:</p>
<pre>
  Sequence: arbababbbbbbbbbccc
  Result:      ababbbbbbbbbccc
</pre><h3><code>count</code> and <code>count_if</code>: Count elements</h3>
<p>The last algorithm considered in this post is <code>count</code>, with its variation <code>count_if</code>. As expected, it counts the number of elements (possibly, matching a predicate):</p>
<div class="hll"><pre><span></span><span class="n">string</span> <span class="n">seq</span><span class="p">{</span><span class="s">&quot;arbababbbbbbbbbccc&quot;</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">count_if</span><span class="p">(</span><span class="n">seq</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">seq</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
        <span class="p">{</span> <span class="k">return</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">&#39;b&#39;</span><span class="p">;</span> <span class="p">});</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Result:  &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
<p>and it counts 11 occurrences.</p>
<h3>Conclusions</h3>
<p>In this installment, we have seen examples of some variations of <code>find</code>, plus a way to count occurrences of an element in a sequence. At this point, the algorithms in the <em>non-modifying sequence operations</em> category are mostly over; in the next episode, we are going to wrap them up.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../stl-algorithms-part-3/">STL Algorithms, part 3</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2014-01-06
  </p>
  <ul>
<li><a href="../../stl-algorithms-part-1/">Part 1</a></li>
<li><a href="../../stl-algorithms-part-2/">Part 2</a></li>
<li><a href="../../stl-algorithms-part-3/">Part 3</a></li>
<li><a href="../../stl-algorithms-part-4/">Part 4</a></li>
<li><a href="../../stl-algorithms-part-5/">Part 5</a></li>
</ul>
<p>In the previous posts of this series, we have had a glance at <em>non-modifying sequence algorithms</em>, i.e., the algorithms that are supposed not to modify the elements of a sequence (or at least, the structure of the sequence; see the observations about <code>for_each</code>.</p>
<p>In this installment, as anticipated, we will start looking at the algorithms for searching.</p>
<!-- more -->

<h3><code>find</code></h3>
<p>The STL <code>find</code> algorithms, specified in section [<code>alg.find</code>] of the C++11 standard, are useful when searching elements in the sequence that satisfy some requirements. The basic form has the prototype that follows:</p>
<div class="hll"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">InputIterator</span> <span class="n">find</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
<p>This algorithm looks for the element whose value is, well, <em>value</em>. This implies that the class <code>T</code> has some comparison operator that allows the algorithm to see whether the current element is the right one. For example, if we have a class Card, for which we define an <code>operator==()</code>, then we can use the algorithm as follows:</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">Card</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">val</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Card</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">get_val</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">val</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Card</span><span class="o">&amp;</span> <span class="n">c1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Card</span><span class="o">&amp;</span> <span class="n">c2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">c1</span><span class="p">.</span><span class="n">get_val</span><span class="p">()</span> <span class="o">==</span>  <span class="n">c2</span><span class="p">.</span><span class="n">get_val</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Card</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">get_val</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Card</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="n">Card</span><span class="p">(</span><span class="s">&quot;Ace&quot;</span><span class="p">),</span> <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Deuce&quot;</span><span class="p">),</span> <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Four&quot;</span><span class="p">),</span>
        <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Five&quot;</span><span class="p">),</span> <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Eight&quot;</span><span class="p">),</span> <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Nine&quot;</span><span class="p">),</span>
        <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Jack&quot;</span><span class="p">),</span> <span class="n">Card</span><span class="p">(</span><span class="s">&quot;Queen&quot;</span><span class="p">),</span> <span class="n">Card</span><span class="p">(</span><span class="s">&quot;King&quot;</span><span class="p">)};</span>
    <span class="n">Card</span> <span class="nf">needle1</span><span class="p">(</span><span class="s">&quot;Eight&quot;</span><span class="p">);</span>
    <span class="n">Card</span> <span class="nf">needle2</span><span class="p">(</span><span class="s">&quot;Seven&quot;</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">needle1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">verb</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
        <span class="n">verb</span> <span class="o">=</span> <span class="s">&quot; is&quot;</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">verb</span> <span class="o">=</span> <span class="s">&quot; is not&quot;</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Card &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">needle1</span> <span class="o">&lt;&lt;</span> <span class="n">verb</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; in the deck</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">needle2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
        <span class="n">verb</span> <span class="o">=</span> <span class="s">&quot; is&quot;</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">verb</span> <span class="o">=</span> <span class="s">&quot; is not&quot;</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Card &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">needle2</span> <span class="o">&lt;&lt;</span> <span class="n">verb</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; in the deck</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>The output of this program (compiled with clang 3.2.7) is:</p>
<pre>
  Card is in the deck
  Card Seven was not in the deck
</pre><p>Notice that the return type of the algorithm is an iterator in the sequence, so to get the element we could dereference the iterator <em>it</em>.</p>
<h3><code>find_if</code>, <code>find_if_not</code></h3>
<p>One might want to find an element based on some predicate.  This is what the other two forms of <code>find</code> are for. These are their prototypes:</p>
<div class="hll"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="n">InputIterator</span> <span class="n">find_if</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span>
    <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="n">InputIterator</span> <span class="n">find_if_not</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span>
    <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span>
</pre></div>
<p>As seen for the algorithms presented in previous posts, also in this case we can use both a functor or a closure. Let's see an example with closures:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">,</span><span class="mi">6</span><span class="p">};</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">){</span> <span class="k">return</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found even number: &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="c1">// Find next even numbers:</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">find_if</span><span class="p">(</span><span class="n">it</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
            <span class="p">[](</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">){</span> <span class="k">return</span> <span class="n">i</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">())</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Found another even number: &quot;</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>In this example, we look for even numbers in a vector. Since the algorithm is defined for each sequence, we can use the iterator returned by the first invocation of <code>find_if</code> to start another sequence; only we have to be careful to increment it, otherwise, we are going to get the value 2 again. The result, as expected, is:</p>
<pre>
  Found even number: 2
  Found another even number: 4    
</pre><h3>Conclusions</h3>
<p>As you might have noticed so far, the usage of algorithms is fairly intuitive, and they can be very powerful to express ideas.</p>
<p>In the next installments, we'll see some other interesting variants of the <code>find</code> algorithm. Stay tuned!</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../stl-algorithms-part-2/">STL Algorithms, part 2</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-12-30
  </p>
  <ul>
<li><a href="../../stl-algorithms-part-1/">Part 1</a></li>
<li><a href="../../stl-algorithms-part-2/">Part 2</a></li>
<li><a href="../../stl-algorithms-part-3/">Part 3</a></li>
<li><a href="../../stl-algorithms-part-4/">Part 4</a></li>
<li><a href="../../stl-algorithms-part-5/">Part 5</a></li>
</ul>
<h3>Previously on this blog</h3>
<p>In the previous installment, we have introduced three algorithms, <code>all_of</code>, <code>any_of</code>, and <code>none_of</code>, very useful to determine whether a range of elements satisfy some predicate, expressed as a lambda.</p>
<p>In this second episode, we will explore more algorithms offered by the STL. My objective, in the long run, is to cover all of them with examples, and maybe grasp the ideas that might come to my mind during the process. As usual, if you have any doubt or just spot a plain error, I'd greatly appreciate if you let me know.</p>
<!-- more -->

<h3>for_each (Act I)</h3>
<div class="hll"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Function</span><span class="o">&gt;</span>
<span class="n">Function</span> <span class="n">for_each</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Function</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
<p>The algorithms that we have seen so far fall into the category of <em>non-modifying sequence operations</em>, because they can be applied without having to worry about changing the underlying range (or to invalidate the container).  The next few ones fall in the same category.</p>
<p>A very interesting one is the <code>for_each</code> algorithm. It can be used to apply some operation to a range of elements. Things become tricky in this case, because the algorithm requires the function, that we want to apply to the elements in the range, to be <em>MoveConstructible</em>.  I will cover rvalue references and move semantics in one of the next posts (or you can have a look at this excellent <a href="http://holdstare.github.io/technical/2013/11/23/moves-demystified.html">post</a>, the best I have read so far about the subject), but for now it is enough to say that this means what follows.</p>
<h4>Intermezzo: being MoveConstructible</h4>
<p>Being <em>MoveConstructible</em>, for an object (in this case a function object or a lambda), means that it must obey a post-condition. In this case, if we have either of the following expressions:</p>
<div class="hll"><pre><span></span><span class="n">T</span> <span class="n">t</span> <span class="o">=</span> <span class="n">rv</span>
<span class="n">T</span><span class="p">(</span><span class="n">rv</span><span class="p">)</span>
</pre></div>
<p>then the post-condition (in the first case) is that <code>t</code> has the same value that <code>rv</code> used to have, before <code>t</code>'s construction is terminated (that is to say, before this statement), but after <code>t</code> is constructed (and this statement has been executed), no guarantee is given about the state of <code>rv</code> (in particular, its state might be different from the state it had before the assignment). The same is true for the second type of expression.</p>
<p>This requirement is stronger than being required to be <em>CopyConstructible</em>, where the state of <code>rv</code> after the assignment has to stay unchanged.  For now, we can think of move semantics as a way of reducing the number of object creations. To do this, the language offers the chance to change the state of an object being moved from.</p>
<h3><code>for_each</code> (Act II)</h3>
<p>What does this mean with respect to our usage of <code>for_each</code>? This has to do with the return type of the algorithm: it is <code>std::move(f)</code>. Since <code>f</code> is required to be <em>MoveConstructible</em>, this guarantees that, if <code>f</code> is an object with a state, then the returned value has a valid state, even if optimizations are applied when returning it.</p>
<p>It can be exemplified like follows:</p>
<pre>
for each element in the range
    dereference the element
    apply the function f
return a (possibly destructive) copy of f
</pre><p>When returning, the result of the copy is perfectly valid, but the object it is copied from might get altered by the copy operation. The fact that this copy is actually a <em>move</em> is not important to understand the effects.  The net result is: we can neglect this, and leave the responsibility to the implementer of the STL.</p>
<p>An example will make everything clear:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
            <span class="p">[](</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span> <span class="p">});</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">vv</span><span class="p">:</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">vv</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>This will print the numbers 2, 4, 6. Note that the standard specifies that, if <code>f</code> returns a result (which is not the case for our example), that result is ignored. As you can see, even though <code>for_each</code> is supposed to belong to the non-modifying sequence operations, it can alter the values of the elements in the container. This has been object of a discussion; one conclusion is that the <code>for_each</code> itself does not modify the container, while the function <code>f</code> could; another, is that modifying the elements is not equivalent to modifying the sequence's structure (i.e., the <code>for_each</code> does not invalidate the underlying pointers). If you are interested in the fine points of the discussion, you can have a look <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#475">here</a> and <a href="https://stackoverflow.com/questions/662845/why-is-stdfor-each-a-non-modifying-sequence-operation">here</a>.</p>
<h3>Conclusions</h3>
<p>We have seen another fine algorithm offered by the standard template library.  Even though of simple application, this one has been subject to some debate about its classification as non-modifying sequence operation; it has also given me the chance to provide a first (very incomplete!) explanation of what is the move semantics in the C++11 standard.</p>
<p>In the next installment of this series, I am going to talk about algorithms for finding elements in a container (searching algorithms).</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../stl-algorithms-part-1/">STL Algorithms, part 1</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-12-23
  </p>
  <ul>
<li><a href="../../stl-algorithms-part-1/">Part 1</a></li>
<li><a href="../../stl-algorithms-part-2/">Part 2</a></li>
<li><a href="../../stl-algorithms-part-3/">Part 3</a></li>
<li><a href="../../stl-algorithms-part-4/">Part 4</a></li>
<li><a href="../../stl-algorithms-part-5/">Part 5</a></li>
</ul>
<h3>Why algorithms</h3>
<p>Standard algorithms have a prominent value in the C++ standard template library (STL). They present the great advantage of expressing an operation applied on a range of elements in a container. In this series, I am going to review all the algorithms introduced in the C++11 standard, presenting it in digestible chunks, and will provide at least an example of application for each one.</p>
<!-- more -->

<h3><code>all_of</code></h3>
<p>We might want to determine whether all elements in a range satisfy some property. For example, suppose we want to find out if all the persons subscribed to this blog come from Europe. We might keep a record of a Person in the form:</p>
<div class="hll"><pre><span></span><span class="k">enum</span> <span class="nc">Continent</span> <span class="p">{</span>
    <span class="n">EUROPE</span><span class="p">,</span> <span class="n">ASIA</span><span class="p">,</span> <span class="n">AMERICA</span><span class="p">,</span> <span class="n">AFRICA</span><span class="p">,</span> <span class="n">AUSTRALIA</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">Continent</span> <span class="n">continent</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>Now say that we have a <code>std::vector</code> of customers. To find the answer to our previous question, we might do something like the following:</p>
<div class="hll"><pre><span></span><span class="c1">// declare p1, p2, p3</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span> <span class="n">persons</span> <span class="o">=</span> <span class="p">{</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">};</span>
<span class="kt">bool</span> <span class="n">all_european</span> <span class="o">=</span> <span class="n">all_of</span><span class="p">(</span><span class="n">persons</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">persons</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">continent</span> <span class="o">==</span> <span class="n">Continent</span><span class="o">::</span><span class="n">EUROPE</span><span class="p">;</span>
        <span class="p">});</span>
<span class="k">if</span> <span class="p">(</span><span class="n">all_european</span><span class="p">)</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;All European visitors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Visitors from outside Europe</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
<p>Formally, the signature for <code>all_of</code> is:</p>
<div class="hll"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Predicate</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">all_of</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Predicate</span> <span class="n">pred</span><span class="p">);</span>
</pre></div>
<p>One gotcha: the algorithms returns true if the range is empty. It runs in linear time on the number of elements in the range. You can find the complete code is at <a href="https://gist.github.com/sturmer/8082362">this link</a>.</p>
<h3><code>any_of</code></h3>
<p>Now suppose we want to know whether <em>at least one</em> of the customers is American. We can accomplish this with the algorithm <code>std::any_of</code>, which intuitively enough can be used like the following:</p>
<div class="hll"><pre><span></span><span class="c1">// ...</span>
<span class="kt">bool</span> <span class="n">any_american</span> <span class="o">=</span> <span class="n">any_of</span><span class="p">(</span><span class="n">persons</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span>
        <span class="n">persons</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span>
        <span class="p">[](</span><span class="k">const</span> <span class="n">Person</span><span class="o">&amp;</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">.</span><span class="n">continent</span> <span class="o">==</span> <span class="n">Continent</span><span class="o">::</span><span class="n">AMERICA</span><span class="p">;</span>
        <span class="p">});</span>
<span class="k">if</span> <span class="p">(</span><span class="n">any_american</span><span class="p">)</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;We had an American visitor</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="k">else</span>
      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No visitors from Americas</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
<p>As you can see, we recycled the Predicate. The pitfall here is the reverse of the one for all_of: this algorithms returns false if the range is empty. Find the gist <a href="https://gist.github.com/sturmer/8082455">here</a>.</p>
<h3><code>none_of</code></h3>
<p>Let's change example. Say we have a vector of Shape class pointers. Shape can be derived in order to provide more specific properties:</p>
<div class="hll"><pre><span></span><span class="k">struct</span> <span class="nc">Shape</span> <span class="p">{</span>
    <span class="n">Shape</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">float</span> <span class="n">area</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">height</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">width</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">area</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">height</span> <span class="o">*</span> <span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Rectangle</span><span class="p">(</span><span class="kt">float</span> <span class="n">h</span><span class="p">,</span> <span class="kt">float</span> <span class="n">w</span><span class="p">)</span> <span class="o">:</span> <span class="n">height</span><span class="p">(</span><span class="n">h</span><span class="p">),</span> <span class="n">width</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">radius</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">float</span> <span class="n">area</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="mf">3.14</span><span class="p">;</span> <span class="c1">// approx</span>
    <span class="p">}</span>

    <span class="n">Circle</span><span class="p">(</span><span class="kt">float</span> <span class="n">radius</span><span class="p">)</span> <span class="o">:</span> <span class="n">radius</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Triangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{};</span>
</pre></div>
<p>Now we want to see whether in a vector of Shape pointers there is any Triangle.  Since <code>none_of</code> is a negative predicate, and reasoning in negative terms is generally harder, we define the predicate outside the invocation of the algorithm, to make things clearer:</p>
<div class="hll"><pre><span></span><span class="c1">// define rectangles and circles, no triangle</span>
<span class="c1">// put them in a vector</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">*&gt;</span> <span class="n">v</span><span class="p">{</span><span class="o">&amp;</span><span class="n">c1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r4</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">is_triangle</span> <span class="o">=</span> <span class="p">[](</span><span class="n">Shape</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Triangle</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="p">};</span>
<span class="kt">bool</span> <span class="n">no_triangle</span> <span class="o">=</span> <span class="n">none_of</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="n">is_triangle</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">no_triangle</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No triangle</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
<p>We use the <code>dynamic_cast</code> to determine if the pointer points to a Triangle, in which case it would return a non-null pointer. The <code>std::none_of</code> algorithm, as the ones mentioned above, has linear complexity depending on the number of elements in the range. Grab the gist <a href="https://gist.github.com/sturmer/8083022">here</a>.</p>
<h3>In the next episode</h3>
<p>We have covered three basic algorithms for testing properties of elements in a container: <code>all_of</code> checks whether all the elements in a range satisfy a predicate, <code>any_of</code> checks whether at least one element satisfies the predicate, while <code>none_of</code> checks that none of the elements satisfies the predicate. Lambdas give us a way of expressing very clearly the predicate: if you feel uncomfortable with them, you might want to have a look at the mini-series I have written about them (<a href="../../lambdas-in-c11/">part 1</a> and <a href="../../lambdas-in-c11-part-2/">part 2</a>).</p>
<p>In the next installment, we are going to get into more algorithms provided by the standard.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../lambdas-in-c11-part-2/">Lambdas in C++11, part 2</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-12-16
  </p>
  <p>In the <a href="../../lambdas-in-c11/">previous post</a>, I have shown the syntax of lambda expressions in C++11, also known as closures, that are basically unnamed function objects that can be passed around for convenience, enhancing correctness through readability.</p>
<!-- more -->

<p>In this installment, as promised, we will have a look at one of the basic advantages of using lambdas, by first introducing a small Functor (a function class, or, a class with an overloading of <code>operator()</code>), and then seeing it being substituted with a shiny closure.</p>
<h3>Small functor</h3>
<p>In the previous version of the language, several of the STL containers allow the user to provide a class to a container constructor, that encapsulates the notion of order among elements of the container. This notion is important for usage with sorting algorithms (like <code>std::sort</code>), but might become fundamental when using certain containers, like sets or priority queues.</p>
<p>Consider, for example, the following program:</p>
<div class="hll"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;task.hpp&quot;</span><span class="cp"></span>
<span class="c1">// includes, using declarations</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">Task</span> <span class="n">task1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Laundry&quot;</span><span class="p">);</span>
   <span class="n">Task</span> <span class="n">task2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Hackery&quot;</span><span class="p">);</span>
   <span class="n">Task</span> <span class="n">task3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Grocery&quot;</span><span class="p">);</span>
   <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;&gt;</span> <span class="n">q</span><span class="p">;</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task1</span><span class="p">);</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task3</span><span class="p">);</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
       <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>This program declares 3 tasks, each one identified by a priority and a name. The priority queue is defined over the class <code>Task</code>, is implemented with a <code>std::vector</code>, and depends on a standard functor, <code>less</code>. (Having to specify the use of a vector comes unfortunately from the way the <code>priority_queue</code> is designed.)</p>
<p>The <code>std::less</code> class is a convenience class provided by the standard library to be used with containers and algorithms. We can use it to customize the sorting order of the tasks in our priority queue. While the default types have their specialization already, that works mostly out-of-the-box, we need to provide a criterion to our queue for the right sorting. Say, for example, that the sorting is per ascending priority (i.e., task with priority 9 has higher priority than task with priority 0): we would express it like:</p>
<div class="hll"><pre><span></span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
<span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="nc">less</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nf">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">t2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">t1</span><span class="p">.</span><span class="n">priority_</span> <span class="o">&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">priority_</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
<p>Pretty simple: we specialize the template struct for the class <code>Task</code>, and add it to the <code>std</code> namespace. For completeness, let\'s have a look at the <code>Task</code> class declaration:</p>
<div class="hll"><pre><span></span><span class="k">struct</span> <span class="nc">Task</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">priority_</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">description_</span><span class="p">;</span>
    <span class="n">Task</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">string</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">priority_</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">description_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>
<p>If we compile the program, the output of the resulting executable is the following:</p>
<pre>
3: Hackery
2: Grocery
1: Laundry
</pre><h3>Beauty of the lambda</h3>
<p>The point is, we are trying to do something very simple: we only want to pass a function to the <code>priority_queue</code> constructor, to let it do its job of keeping the tasks sorted. In previous versions of the standard, we had to specialize a template struct, and plug it in the <code>std</code> namespace. While certainly not a major feat, try to compare it with the following, closure-based implementation:</p>
<div class="hll"><pre><span></span><span class="c1">// #includes, using declarations</span>
<span class="k">struct</span> <span class="nc">Task</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">priority_</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">description_</span><span class="p">;</span>
    <span class="n">Task</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="n">string</span> <span class="n">d</span><span class="p">)</span> <span class="o">:</span> <span class="n">priority_</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">description_</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">priority_</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">.</span><span class="n">description_</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">Task</span> <span class="nf">task1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Laundry&quot;</span><span class="p">);</span>
   <span class="n">Task</span> <span class="nf">task2</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Hackery&quot;</span><span class="p">);</span>
   <span class="n">Task</span> <span class="nf">task3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Grocery&quot;</span><span class="p">);</span>
   <span class="k">auto</span> <span class="n">compare_tasks</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">t1</span><span class="p">,</span> <span class="k">const</span> <span class="n">Task</span><span class="o">&amp;</span> <span class="n">t2</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t1</span><span class="p">.</span><span class="n">priority_</span> <span class="o">&lt;</span> <span class="n">t2</span><span class="p">.</span><span class="n">priority_</span><span class="p">;</span> <span class="p">};</span>
   <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">Task</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">decltype</span><span class="p">(</span><span class="n">compare_tasks</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">(</span><span class="n">compare_tasks</span><span class="p">);</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task1</span><span class="p">);</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span>
   <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">task3</span><span class="p">);</span>
   <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
       <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>We don't even need a separate header, because we have no template. The only trick here is to wrap the parameter <code>compare_tasks</code> in a <code>decltype</code>. In a nutshell, <code>decltype</code> returns the type of the expression used as its argument (but see [<code>dcl.type.simple</code>] in the standard for the precise definition). This is necessary, because a template parameter needs be a class, or the result of an expression that can be computed at compile time. The lambda is not a class, but an object of anonymous type: see, for example, again [<code>expr.prim.lambda</code>]:</p>
<blockquote><p>The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed non- union class type [...]</p>
</blockquote>
<p>This means that we need a way to express the type of the lambda. One way to do it is that first we define the lambda to be of type auto, and then we express the type itself as the result of a <code>decltype</code> evaluation, which is equivalent to saying: _Whatever is the type of this closure, feed it to the priority<em>queue constructor</em>. This solves the problem, and makes the program compilable and the output identical to the version with functors.</p>
<p>See also this <a href="http://stackoverflow.com/a/3867323">Stack Overflow answer</a> for a thorough discussion about the advantages and disadvantages of this solution: I found it really useful to understand the need for <code>decltype</code>.</p>
<h3>Conclusion</h3>
<p>Lambdas provide a convenient, readable, and concise way to express the notion of a function object. They are useful in every context where it is necessary to pass a function around, like to implement callback mechanisms, and notably as function objects that interact nicely with STL algorithms and containers. As a side-note, let me confess that I prefer to call them <em>closures</em> only because I am not able to spell the word <em>lambda</em> correctly on the fly (when out of Vim, of course :)).</p>
<p>This concludes our mini-tour of the closures in C++11. As usual, the complete version of the code we have discussed in this post is available as a <a href="https://gist.github.com/sturmer/7915819">Gist</a>.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../lambdas-in-c11/">Lambdas in C++11</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-12-09
  </p>
  <p>Lambda expressions have been introduced to C++ with the most recent standard, presented in Section [<code>expr.prim.lambda</code>]. They allow the creation of simple functions without giving them a name. What are they good for? Being <em>simple</em> is not really the point here; the most useful case that I have found in my limited experience has been as a convenient replacement for Functors (also known as Function objects).</p>
<p>In this post, I'll give a quick introduction to how to use lambdas in your code. In the next installment, I will discuss a small example of functor, and will show side by side a piece of code with functors and its substitution with a clean lambda.</p>
<!-- more -->

<h3>How do I write one? (Syntax)</h3>
<p>Maybe the simplest compilable (tried with gcc 4.8.1 with option <code>-std=c++0x</code>) lambda has the following syntax:</p>
<div class="hll"><pre><span></span><span class="p">[](){};</span>
</pre></div>
<p>This lambda however is not very useful, so we might try something a tad harder:</p>
<div class="hll"><pre><span></span><span class="p">[](){</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
<p>This is a simple function that returns 1. What if you want to use a parameter? You would do:</p>
<div class="hll"><pre><span></span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span> <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
<p>This is a simplistic <em>incrementer</em> of an int variable.</p>
<p>Things start becoming interesting when we start using the capture feature. Consider the following snippet:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">[</span><span class="o">=</span><span class="n">x</span><span class="p">](){</span> <span class="k">return</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
<p>This just says: <em>capture</em> the <em>value</em> of the variable <code>x</code> from the outer scope, and return its value plus 1. The obscure rune between brackets is just the symbol <code>=</code> followed by the name of the variable, that means: capture by value. If we want to actually change the value of the variable, we need to capture by reference. This is promptly done:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">[</span><span class="o">&amp;</span><span class="n">x</span><span class="p">](){</span> <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
</pre></div>
<p>We just use the symbol <code>&amp;</code>, and we are done. Note that the code snippets above actually do not do anything useful, because we are just declaring the lambda without ever using it. Notice however that this behavior is not considered an error by the compiler, even at the highest warning level (which you always enable, right?).</p>
<p>There are a couple of shortcuts: if we want to capture all the variables by value, we can just write a lonely <code>=</code> between brackets; the same applies to the case of capture "everything by reference". In particular, if we want to capture everything by value, but y, which we want by reference, we can write:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">z</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">](){</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
<h3>Return of a value</h3>
<p>The truth is, so far we have been using a shortcut. In a lambda we can also specify a return value; if we do not, then the return type is determined by the following rule: if there is a return statement with an expression, then the return type is the result of the expression after its evaluation; otherwise it is void. To specify explicitly a return type (useful when dealing with template types), we use the syntax</p>
<div class="hll"><pre><span></span><span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">]()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
<p>By the way, if we have no parameters we can omit the parentheses:</p>
<div class="hll"><pre><span></span><span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">]</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">;</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
<h3>Passing lambdas around: The <a href="std::function">std::function</a></h3>
<p>Now let's see the most interesting use of lambdas, or their interactions with STL algorithms. Consider the following snippet (the complete source is <a href="https://gist.github.com/sturmer/7775326" title="Source code of the filter example">here</a>):</p>
<div class="hll"><pre><span></span><span class="c1">// Print the string if it satisfied the constraint f</span>
<span class="kt">void</span> <span class="nf">filter</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">string</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39;&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&#39; &quot;</span><span class="p">;</span>
            <span class="o">++</span><span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ifstream</span> <span class="n">f</span><span class="p">(</span><span class="s">&quot;/home/gc/Downloads/pg44327.txt&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error: can&#39;t open file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
        <span class="n">filter</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">;</span> <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Consider what is done there in the main function: the function <code>filter</code> takes a vector and a lambda. The signature features the template <code>std::function</code> (to be found in the header <code>&lt;functional&gt;</code>, and is used to simplify a parameter that takes a string as only argument, and returns a <code>bool</code>. Now have a look at the way the function <code>filter</code>: the second argument is a lambda that takes a string argument and, not surprisingly, returns a <code>bool</code> (returns true if the string is longer than 3).</p>
<p>For completeness, here is the text of the function Split. Watch out: it is far from perfect (consider what happens when 2 consecutive characters occur, which are equal to the ones I discard; plus, it is not i18n-ready). It should split a line into words:</p>
<div class="hll"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Split</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">line</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">&quot; [];,.&quot;</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">oldpos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">!=</span> <span class="n">oldpos</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">oldpos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">oldpos</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="n">oldpos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">line</span><span class="p">.</span><span class="n">find_first_of</span><span class="p">(</span><span class="s">&quot; [];,.&quot;</span><span class="p">,</span> <span class="n">oldpos</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h3>Using it in algorithms</h3>
<p>We can actually do the work of the previous example with less code, using STL algorithms:</p>
<div class="hll"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">generate</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ifstream</span> <span class="n">f</span><span class="p">(</span><span class="s">&quot;/home/gc/Documents/diary/cervantes-20130202.txt&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Error: can&#39;t open file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">string</span> <span class="n">line</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">Split</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">count_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">value</span><span class="p">;</span> <span class="p">});</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">cnt</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; words longer than &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Here the interesting line is the one that sports the call to <code>std::count_if</code>. It is an algorithm that takes a range and a function that expresses a condition that, if true, makes it count the element. The result is accumulated in the <code>cnt</code> variable.</p>
<p>As another example, look at this extremely concise way of printing a container:</p>
<div class="hll"><pre><span></span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">line</span><span class="p">;</span>
<span class="c1">// ... push_back of values</span>
<span class="n">for_each</span><span class="p">(</span><span class="n">line</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span> <span class="n">line</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span> <span class="p">[](</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">});</span>
</pre></div>
<p>The <code>for_each</code> algorithm takes a range and performs the action determined by the lambda passed as third argument. I find this really neat!</p>
<h3>Conclusions</h3>
<p>But so what is the real advantage of using lambdas over functors?</p>
<p>In the next installment, we will see an example of functor, and which advantage we actually get from using lambdas over functors.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../write-an-interface-between-your-program-and-a-shared-object/">Write an Interface between your Program and a Shared Object</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-12-02
  </p>
  <p>I wanted to share something I've been doing for some hours today, in the hope to understand it better. I also hope to receive criticism on this, because there might be a better way to do the same thing, only more elegantly. This is no research problem, as I am sure it has been solved time and again in different contexts; but the whole example, comprising all the pieces put together in this post, is something I have not seen around, and I think it can be of some service if I explain it.</p>
<!-- more -->

<h3>Problem</h3>
<p>We have an application that uses a resource offered by the operating system. I am on a GNU/Linux, so for example the resource is a file in the <em>proc/</em> file system, say <em>version</em>. The application works like the following:</p>
<div class="hll"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;server_operations.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ServiceOps</span> <span class="n">ops</span><span class="p">;</span>
    <span class="n">string</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ops</span><span class="p">.</span><span class="n">GetResource</span><span class="p">(</span><span class="s">&quot;version&quot;</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Result is:</span><span class="se">\n\&quot;\&quot;\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;\&quot;\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>The class <code>ServiceOps</code> encapsulates the fact that the resource with the name <em>version</em> is actually a file being opened. It has the following structure:</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">ServiceOps</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetResource</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
<p>The implementation just opens a file with name <code>name</code>, prefixing it with <code>/proc/</code>. Easy. As usual, for the details refer to the <a href="gttps://gist.github.com/sturmer/7713229" title="Client, stand-alone">gist</a>.</p>
<h4>A Shared Object</h4>
<p>There is another piece of code. This one provides some services, and is built as a Linux shared object. It holds a pointer to a class <code>Resource</code>, which in turn holds a dictionary. It comprises two classes:</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">Resource</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Provider</span> <span class="p">{</span>
    <span class="n">Resource</span><span class="o">*</span> <span class="n">r_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">Provider</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetResource</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="n">string</span><span class="o">&gt;</span> <span class="n">dict_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">Resource</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">GetName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">surname</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
<p>In this case, the resource is a dictionary (instead of the <code>/proc/version</code> file).</p>
<p>We want to connect these 2 pieces and make them independently compilable, meaning that the changes made either one should not affect the other. We want to be able, in particular, to recompile the shared object without recompiling the program, and have the program reflect the change in the shared object; and vice versa, a change in the program not affecting the shared object.</p>
<p>Whimsical as it might seem, this exercise has been inspired by an actual need I had in a real scenario. We want to be able to have old programs, that used to ask services to a library, now ask the same services to our own component. The complete code for the shared object can be found <a href="https://gist.github.com/sturmer/7713293" title="Provider module">here</a>.</p>
<h3>The solution: Adding an interface and Using Dynamic Linking</h3>
<p>The way I found to solve the problem is the following. Imagine you have another header file, that works as an interface. The client code only needs to know the interface; it will be in charge of asking the service to the provider. But to make the provider independent from the interface, we have to load the shared object at run-time, with dynamic linking and the good old <code>dlopen</code>. Now, since the provider is a C++ class, we export two C functions, <code>create</code> and <code>destroy</code>, to allow for, well, the creation and the destruction of an object of the class <code>Provider</code>. The creator, specifically, will only return a pointer, through which we'll call the <code>Provider</code>'s methods directly. I might be childish, but I found this almost poignant: we only use <code>dlopen</code>/<code>dlclose</code>/<code>dlsym</code> in the constructor and destructor of the interface, and nowhere else. No need to <code>dlsym</code> every function (after having to export it). We do not even need to declare the <code>extern "C"</code> creation/destruction functions in the header of the provider: we only write them in its implementation file.</p>
<p>Please have a look at what changed in the Provider's implementation: before, as a stand-alone component, it was:</p>
<div class="hll"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;provider.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;resource.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="n">Provider</span><span class="o">::</span><span class="n">Provider</span><span class="p">()</span> <span class="o">:</span> <span class="n">r_</span><span class="p">(</span><span class="k">new</span> <span class="n">Resource</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">clog</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Provider::Provider()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Provider</span><span class="o">::</span><span class="n">GetResource</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">clog</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Provider::GetResource()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r_</span><span class="o">-&gt;</span><span class="n">GetName</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Now, we only need to add:</p>
<div class="hll"><pre><span></span><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
    <span class="n">Provider</span><span class="o">*</span> <span class="nf">create</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Provider</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">Provider</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Pretty unobtrusive, ain't it?</p>
<h3>The Star of the Show</h3>
<p>Of course we did not forget the interface that makes all this possible:</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">Provider</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">ProviderInterface</span> <span class="p">{</span>
    <span class="n">Provider</span><span class="o">*</span> <span class="n">impl_</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">so_handle_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
    <span class="n">ProviderInterface</span><span class="p">();</span>
    <span class="n">string</span> <span class="nf">GetResource</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
    <span class="o">~</span><span class="n">ProviderInterface</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
<p>implemented as</p>
<div class="hll"><pre><span></span><span class="c1">// ...</span>
<span class="cp">#include</span> <span class="cpf">&lt;dlfcn.h&gt;</span><span class="cp"></span>

<span class="n">ProviderInterface</span><span class="o">::</span><span class="n">ProviderInterface</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">clog</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ProviderInterface::ProviderInterface()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">so_handle_</span> <span class="o">=</span> <span class="n">dlopen</span><span class="p">(</span><span class="s">&quot;./provider_module/libprovider.so&quot;</span><span class="p">,</span> <span class="n">RTLD_LAZY</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">dlerror</span><span class="p">();</span>
    <span class="n">Provider</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">get_provider</span><span class="p">)();</span>
    <span class="n">get_provider</span> <span class="o">=</span> <span class="p">(</span><span class="n">Provider</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">dlsym</span><span class="p">(</span><span class="n">so_handle_</span><span class="p">,</span> <span class="s">&quot;create&quot;</span><span class="p">);</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">impl_</span> <span class="o">=</span> <span class="n">get_provider</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">string</span> <span class="n">ProviderInterface</span><span class="o">::</span><span class="n">GetResource</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clog</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ProviderInterface::GetResource()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">impl_</span><span class="o">-&gt;</span><span class="n">GetResource</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">ProviderInterface</span><span class="o">::~</span><span class="n">ProviderInterface</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">clog</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ProviderInterface::~ProviderInterface()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">dlerror</span><span class="p">();</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_provider</span><span class="p">)(</span><span class="n">Provider</span><span class="o">*</span><span class="p">);</span>
    <span class="n">destroy_provider</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Provider</span><span class="o">*</span><span class="p">))</span><span class="n">dlsym</span><span class="p">(</span><span class="n">so_handle_</span><span class="p">,</span> <span class="s">&quot;destroy&quot;</span><span class="p">);</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">error</span> <span class="o">=</span> <span class="n">dlerror</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">error</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">destroy_provider</span><span class="p">(</span><span class="n">impl_</span><span class="p">);</span>
    <span class="n">dlclose</span><span class="p">(</span><span class="n">so_handle_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>and a typical usage in a main program:</p>
<div class="hll"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ProviderInterface</span><span class="o">*</span> <span class="n">iface</span><span class="p">(</span><span class="k">new</span> <span class="n">ProviderInterface</span><span class="p">);</span>
    <span class="n">string</span> <span class="n">result</span> <span class="o">=</span> <span class="n">iface</span><span class="o">-&gt;</span><span class="n">GetResource</span><span class="p">(</span><span class="s">&quot;Liskov&quot;</span><span class="p">);</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Result is:</span><span class="se">\n\&quot;\&quot;\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\&quot;\&quot;\&quot;</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>Needless to say, this time the resource will not be the content of a file, but the name of <a href="https://en.wikipedia.org/wiki/Barbara_Liskov">Doctor Liskov</a>, Turing Award winner.</p>
<h3>The Two Tests: A Conclusion</h3>
<p>Now, if you believe me, you can separately compile the main program and the shared library; if you do not, just download the <a href="https://github.com/sturmer/separation_test" title="Complete toy project">git project</a> and play with it.</p>
<p>Do [sic] try this at home!</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../exploring-the-boost-graph-library-part-2/">Exploring the Boost Graph Library, part 2</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-11-25
  </p>
  <p>This is the second episode of my series on the Boost Graph Library. You might want to read <a href="../../exploring-the-boost-graph-library/">part 1</a> before going on. As before, our primary source is the <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/quick_tour.html">Quick Tutorial</a> that you can find on the BGL web page.</p>
<!-- more -->

<h3>Today's goal</h3>
<p>At the end of this post, you will be able to apply one of the existing graph algorithms implemented in the BGL. We will also cover the notion of <em>vertex descriptor</em> along the way.</p>
<h2>We were saying</h2>
<p>We are analyzing a graph G of 6 vertices:</p>
<p><img src="../../../images/clrs-22.4.png" alt="Graph six nodes"></p>
<p>In the previous installment, we had created the graph and simply printed the indices of the vertices. Now, we are going to see how to apply Dijkstra's algorithm to our graph.</p>
<p>In order to apply the algorithm, we slightly modify our graph so as to contain one more edge, and assign weights to the edges, obtaining the following result (the new edge is dashed):</p>
<p><img src="../../../images/clrs-22.4-weighted1.png" alt="dijkstra graph"></p>
<h3>Internal properties of a graph</h3>
<p>First, let's modify our graph to add an Edge property. We have said that properties can be attached to a BGL graph; there are, however, two types of properties. <em>Internal properties</em> are intrinsically related to the graph itself: for example, the weight of an edge. There are other properties, called <em>external properties</em>, which are only attached to the components of the graph by an algorithm, like the color of a vertex.</p>
<p>The Graph constructor provides slots that can be filled with properties.</p>
<div class="hll"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">OutEdgeListS</span> <span class="o">=</span> <span class="n">vecS</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">VertexListS</span> <span class="o">=</span> <span class="n">vecS</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">DirectedS</span> <span class="o">=</span> <span class="n">directedS</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">VertexProperty</span> <span class="o">=</span> <span class="n">no_property</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">EdgeProperty</span> <span class="o">=</span> <span class="n">no_property</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">GraphProperty</span> <span class="o">=</span> <span class="n">no_property</span><span class="p">,</span>
          <span class="k">class</span> <span class="nc">EdgeListS</span> <span class="o">=</span> <span class="n">listS</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">adjacency_list</span>
</pre></div>
<p>As you can see, the slot reserved to the EdgeProperty is the fifth. To fill all the slots before that, which we do not really care of presently, we can use the convenient structure <code>no_property</code>, not surprisingly defined as:</p>
<div class="hll"><pre><span></span><span class="k">struct</span> <span class="nc">no_property</span> <span class="p">{};</span>
</pre></div>
<p>So the only modification we want to apply to the graph defined in the previous post is:</p>
<div class="hll"><pre><span></span><span class="k">typedef</span> <span class="n">adjacency_list</span><span class="o">&lt;</span><span class="n">vecS</span><span class="p">,</span> <span class="n">vecS</span><span class="p">,</span> <span class="n">directedS</span><span class="p">,</span>
        <span class="n">no_property</span><span class="p">,</span> <span class="n">property</span><span class="o">&lt;</span><span class="n">edge_weight_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">Graph</span><span class="p">;</span>
</pre></div>
<p>This way, we are stating that the edges of our graph have a property, the weight, whose type is an <code>int</code>. The property is attached to the Graph and can be used by the relevant algorithms.</p>
<h2>Apply the algorithm</h2>
<p>To understand what we need to feed to Dijkstra's algorithm in the BGL, let's have a look at the prototype that we are going to use:</p>
<div class="hll"><pre><span></span>  <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">VertexListGraph</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Param</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Tag</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Rest</span><span class="o">&gt;</span>
  <span class="kr">inline</span> <span class="kt">void</span>
  <span class="n">dijkstra_shortest_paths</span>
    <span class="p">(</span><span class="k">const</span> <span class="n">VertexListGraph</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span>
     <span class="k">typename</span> <span class="nc">graph_traits</span><span class="o">&lt;</span><span class="n">VertexListGraph</span><span class="o">&gt;::</span><span class="n">vertex_descriptor</span> <span class="n">s</span><span class="p">,</span>
     <span class="k">const</span> <span class="n">bgl_named_params</span><span class="o">&lt;</span><span class="n">Param</span><span class="p">,</span><span class="n">Tag</span><span class="p">,</span><span class="n">Rest</span><span class="o">&gt;&amp;</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
<p>This is the simplest form of the algorithm, and it does a lot of work for you. To call it, we only need the graph, the descriptor of the vertex that must represent the source from which the distances are to be computed (more on descriptors in a bit), and finally a reference to a some structure containing the parameters. Now this last bit is actually our algorithm return type, and we just pass a <code>RandomAccessIterator</code> on some container holding the weights of the edges, in the order we have used when describing them.</p>
<h4>Intermezzo: Did you say vertex descriptor?</h4>
<p>Graph representations are not all created equal, of course. To refer to a vertex, or to an edge, some representations store pointers to vertex objects, other store vertex objects themselves. Using the BGL, we do not want to care: we refer to an opaque data structure known as _vertex<em>descriptor</em>, listed among the <code>graph_traits</code> of a <code>Graph</code> object. Functions, like <code>edges()</code> or <code>adjacent_vertices()</code>, and functions on <code>property_maps</code>, all rely on the Graph describing the way it wants to store the vertices (and the edges).</p>
<p>This said, let's get back to work.</p>
<h3>Apply the algorithm (continuing)</h3>
<p>To apply Dijkstra's algorithm, we need a start vertex and a list that can hold enough elements for receiving the distances from the start vertex. We do this by defining:</p>
<div class="hll"><pre><span></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distances</span><span class="p">(</span><span class="n">num_vertices</span><span class="p">(</span><span class="n">g</span><span class="p">));</span>
    <span class="n">V</span> <span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">vertices</span><span class="p">(</span><span class="n">g</span><span class="p">).</span><span class="n">first</span><span class="p">);</span>
</pre></div>
<p>The final touch is a breeze:</p>
<div class="hll"><pre><span></span><span class="n">dijkstra_shortest_paths</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">distance_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
</pre></div>
<p>You can have a look at the complete example in this <a href="https://gist.github.com/sturmer/7614390#file-apply_dijkstra-cpp">gist</a>.</p>
<p>Printing the results show the following:</p>
<pre><code>distances from start vertex:
distance(0) = 0
distance(1) = 6
distance(2) = 1
distance(3) = 4
distance(4) = 5
</code></pre>
<h3>Let's break it</h3>
<p>We know from graph theory that Dijkstra does not work well if a weight is negative (it is related to the fact that passing through the negative-weighted edge keeps on decreasing the cost of the path, so it might generate infinite loops). In case by accident we put in a negative weight, the library is so kind as to remind us of our mistake:</p>
<pre><code>what():  The graph may not contain an edge with negative weight.
</code></pre>
<h3>What's next</h3>
<p>In the next installment, we are going to show what a visitor is in this context, and how we can use it.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../exploring-the-boost-graph-library/">Exploring the Boost Graph Library</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2013-11-18
  </p>
  <p><a href="../../exploring-the-boost-graph-library-part-2/">Part 2</a></p>
<p>With this post I'm starting a series about the Boost Graph LibraryÂ (BGL). My objective is to present the material in small,Â easy-to-digest chunks, in order to build an understanding of thisÂ library and of the C++ concepts that it uses.</p>
<!-- more -->

<p>The code is a only a slight variation of the code presented in the <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/quick_tour.html">quick tutorial</a> section about the BGL.Â For a copy of the example revised as it appears in this post, see this <a href="https://gist.github.com/sturmer/7498715" title="Compilable code example">gist</a>.</p>
<h3>Representing the graph</h3>
<p>First off, we know that a graph is representable in a couple of ways.Â One of these is the adjacency list, a data structure where we have aÂ correspondence between each node and all its neighbors, i.e., theÂ nodes that are 1 edge away. So for a graph like:</p>
<p><img src="../../exploring-the-boost-graph-library/clrs-22.4.png" alt="CLRS 22.4"></p>
<p>the adjacency list would look like:</p>
<pre>
1: 2, 4
2: 5
3: 5, 6
4: 2
5: 4
6: 6
</pre><p>(this graph can be found on CLRS).</p>
<p>To represent this list, we declareÂ that our Graph <em>is</em> its adjacency list:</p>
<div class="hll"><pre><span></span><span class="k">typedef</span>
    <span class="n">adjacency_list</span><span class="o">&lt;</span><span class="n">vecS</span><span class="p">,</span> <span class="n">vecS</span><span class="p">,</span> <span class="n">bidirectionalS</span><span class="o">&gt;</span>
    <span class="n">Graph</span><span class="p">;</span>
</pre></div>
<p>This means: use <code>std::vector</code> for out-edges (the edges that are directed from the node outward) and for the vertex set. Other choices might have been, among the others, <code>listS</code> and <code>setS</code>. What we actually choose depends on the application, because some data structures optimize for space, other for times (see this <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/using_adjacency_list.html#sec:choosing-graph-type">brief yet complete and very useful discussion</a>).</p>
<div class="hll"><pre><span></span><span class="k">enum</span> <span class="p">{</span> <span class="n">_1</span><span class="p">,</span> <span class="n">_2</span><span class="p">,</span> <span class="n">_3</span><span class="p">,</span> <span class="n">_4</span><span class="p">,</span> <span class="n">_5</span><span class="p">,</span> <span class="n">_6</span><span class="p">,</span> <span class="n">N</span> <span class="p">};</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">num_vertices</span> <span class="o">=</span> <span class="n">N</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;CLRS_22.4&quot;</span><span class="p">;</span>
</pre></div>
<p>Nothing special here: we decide to give identifiers to the nodes for our convenience. With this setup, we use those <code>enum</code> values to actually create the array of the edges:</p>
<div class="hll"><pre><span></span><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">Edge</span><span class="p">;</span>
<span class="n">Edge</span> <span class="n">edge_array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Edge</span><span class="p">(</span><span class="n">_1</span><span class="p">,</span><span class="n">_2</span><span class="p">),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">_1</span><span class="p">,</span><span class="n">_4</span><span class="p">),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">_2</span><span class="p">,</span><span class="n">_5</span><span class="p">),</span>
  <span class="n">Edge</span><span class="p">(</span><span class="n">_4</span><span class="p">,</span><span class="n">_2</span><span class="p">),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">_5</span><span class="p">,</span><span class="n">_4</span><span class="p">),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">_3</span><span class="p">,</span><span class="n">_5</span><span class="p">),</span>
  <span class="n">Edge</span><span class="p">(</span><span class="n">_3</span><span class="p">,</span><span class="n">_6</span><span class="p">),</span> <span class="n">Edge</span><span class="p">(</span><span class="n">_6</span><span class="p">,</span><span class="n">_6</span><span class="p">)</span>
<span class="p">};</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">num_edges</span> <span class="o">=</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="n">edge_array</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Edge</span><span class="p">);</span>
</pre></div>
<p>Finally we define the graph (note that we only use the <code>edge_array</code>, and we use it as an iterator):</p>
<div class="hll"><pre><span></span><span class="n">Graph</span> <span class="nf">g</span><span class="p">(</span><span class="n">edge_array</span><span class="p">,</span>
    <span class="n">edge_array</span> <span class="o">+</span> <span class="n">num_edges</span><span class="p">,</span>
    <span class="n">num_vertices</span><span class="p">);</span>
</pre></div>
<h3>Properties of a Graph object</h3>
<p>A great feature of the BGL is the availability of fully customizable <em>properties</em>, that can be assigned to vertices and edges, according to the application we are modeling. They can be weights, for example, if we are going to use Dijkstra's algorithm for the shortest path. A property is accessed through a <code>property_map</code> object. Among the properties already defined, we can find the index of the vertices, that we access with a call to the <code>get()</code> function:</p>
<div class="hll"><pre><span></span><span class="k">typedef</span>
  <span class="n">property_map</span><span class="o">&lt;</span><span class="n">Graph</span><span class="p">,</span> <span class="n">vertex_index_t</span><span class="o">&gt;::</span><span class="n">type</span>
  <span class="n">IndexMap</span><span class="p">;</span>
<span class="n">IndexMap</span> <span class="n">index</span> <span class="o">=</span> <span class="n">get</span><span class="p">(</span><span class="n">vertex_index</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span>
</pre></div>
<p>Now let's just print the vertices, using our index property:</p>
<div class="hll"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;vertices(g) = &quot;</span><span class="p">;</span>
<span class="k">typedef</span>
  <span class="n">graph_traits</span><span class="o">&lt;</span><span class="n">Graph</span><span class="o">&gt;::</span><span class="n">vertex_iterator</span>
  <span class="n">vertex_iter</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vertex_iter</span><span class="p">,</span> <span class="n">vertex_iter</span><span class="o">&gt;</span> <span class="n">vp</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">vp</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>
     <span class="n">vp</span><span class="p">.</span><span class="n">first</span> <span class="o">!=</span> <span class="n">vp</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
     <span class="o">++</span><span class="n">vp</span><span class="p">.</span><span class="n">first</span><span class="p">)</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">index</span><span class="p">[</span><span class="o">*</span><span class="n">vp</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
<p>We use <code>graph_traits</code> to get the right iterator. The Iterator concept is crucial to the BGL library, and is an evolution of the same concept in STL, in that the graph iterator differs according to how we want to traverse the graph: by vertices, by adjacency, by visitor.</p>
<p>The iterator we get here is a <code>vertex_iterator</code>, which, not surprisingly, allows us to traverse the list of vertices. The function</p>
<div class="hll"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">vertex_iterator</span><span class="p">,</span> <span class="n">vertex_iterator</span><span class="o">&gt;</span> <span class="n">vertices</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
</pre></div>
<p>which is part of the <code>VertexListGraph</code> interface, returns a range as a pair of iterators to first element and one past the last. Given the property_map object, we index it by unreferencing the iterator, getting the output:</p>
<pre>
vertices(g) = 0 1 2 3 4 5
</pre><h3>What's next</h3>
<p>We have seen how to create a graph, and how to get access to its vertex indices.</p>
<p>In the next installment, we are going to see how to apply some famous graph algorithm with this nice library.</p>

  </div>

  

  
  <div class="pagination">
    
      <a href="../4/">&laquo; Previous</a>
    
    | 5 |
    
      <a href="../6/">Next &raquo;</a>
    
  </div>


  </div>
  <footer>
    &copy; Copyright 2021 by Gianluca Ciccarelli.
  </footer>
</body>
