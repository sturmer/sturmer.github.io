<!doctype html>
<meta charset="utf-8">
<link rel="stylesheet" href="../../../static/style.css">
<title>Blog — Gergelim</title>
<body>
  <header>
    <h1>Gergelim</h1>
    <nav>
      <ul class="nav navbar-nav">
        <li><a href="../../../">Welcome</a></li>
        
          <li class="active"><a href="../../">Blog</a></li>
        
          <li><a href="../../../projects/">Projects</a></li>
        
          <li><a href="../../../about/">About</a></li>
        
      </ul>
    </nav>
  </header>
  <div class="page">
    
  
    
  <div class="blog-post">
  
    <h2><a href="../../retrospective-november-2019-january-2020/">Retrospective November 2019 - January 2020</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2020-02-02
  </p>
  <h5>Goal: Reading as much as possible</h5>
<p>Good enough on this one. If I've counted right, I've read 4 books in this time. But I am writing less about them.</p>
<h5>Goal: Learning Estonian and Russian</h5>
<p>Taking a hiatus on these two. Finished my Estonian A1.1 but didn't enjoy the course format. I dropped out of the Russian one.</p>
<h5>Goal: Make the Reading Apéro popular in Estonia</h5>
<p>This will take more work but I've done 3 already and there was people each time</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../nodejs-in-action-by-alex-young-et-al-510/">Node.js in Action, by Alex Young et al. (5/10)</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2019-12-29
  </p>
  <p><a href="https://www.librarything.com/work/20255574/">
    <img src="nodejs-in-action.jpg" width="150" alt="Node.js in Action" />
</a></p>
<p>Like several resources I've found that claim to talk about Node.js, this one talks instead (and at length) about the most used frameworks. It is useful if you are interested in the Node ecosystem, but it starts pretty quickly to feel like reading a catalog or a white paper.</p>
<p>If you want to understand how the event loop works, how to use streams, and when to start using clustering, then you'll need to look elsewhere.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../retrospective-september-october-2019/">Retrospective September-October 2019</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2019-10-30
  </p>
  <h5>Goal: Getting back in shape with problem-solving</h5>
<p><strong>What I wanted to do:</strong> <em>Lately, I've reflected on side projects and career growth in general. Often I want to start some side project without having a real problem that I want solved. In the long run, this deprives me of motivation and I end up giving up.</em></p>
<p><em>I want to stay open to start one project when I feel I've got something interesting to develop, but I don't want to create yet another implementation of a solved problem (it was a markdown parser last time).</em></p>
<p><em>Programming contests offer problems that don't require weeks of work but can be worked on in a single session (30-120 minutes). I'll stick to them for a while.</em></p>
<p><strong>Outcome:</strong> ❌ Haven't solved a single problem. <em>Lesson</em>: if I don't see value in this, I'll never allocate time to do it. Open source still makes more sense.</p>
<h5>Goal: Focused courses on PluralSight</h5>
<p><strong>What I wanted to do:</strong> <em>I'm trying PluralSight because I've seen a <a href="https://www.pluralsight.com/courses/nodejs-advanced">very interesting and to-the-point course on Node</a>. My experience with books has been pretty negative recently, so I want to see if it gets better with the course format. I'm going through the very thorough <a href="https://learndocker.online/">Learn Docker course</a> and if feels like I'm learning valuable things that help me doing my day-to-day job.</em></p>
<p><strong>Outcome:</strong>
✅ I have finished the Node course and gotten a better understanding of Node. I appreciate the instructor's care about the learner's retention and suggesting to go back to the lectures that I feel less confident about. I'll try to do that but I'm pessimist about me actually managing to.</p>
<p>❌ I've somehow abandoned the Docker course for lack of interest but I might get back to it as Docker is a useful tool.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../peopleware-productive-projects-and-teams-by-tom-demarco-and-timothy-lister-410/">Peopleware: Productive Projects and Teams, by Tom DeMarco and Timothy Lister (4/10)</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2019-04-06
  </p>
  <p><a href="https://www.librarything.com/work/17188/">
    <img src="peopleware.jpg" width="150" alt="Peopleware: Productive Projects and Teams" />
</a></p>
<p>This central tenet of this book is that software development is not a technological problem but a social one. 
<!-- more --></p>
<p>It contains several good points, yet it felt like rehashing of wisdom already common among conscentious programmers (whose lot I strongly believe I belong to). It's totally possible that it contributed in large part to that same wisdom but then reading it was like having a conversation with myself trying to convince me of what I'm already convinced of: Leave the programmer as quiet as possible and offer her the choice over the whole spectrum of possibility that ranges from complete isolation to total social immersion.</p>
<p>A novel concept for me and worth a mention is the one according to which the intrinsic motivation of a programmer is curtailed when she's asked to give up the quality of the software she's developing in favor of arbitrary deadlines. The quality seen by the programmer is in general superior to the one required by the customer yet if the standard is dictated by the latter then the former starts feeling demotivated as she's no longer proud of what she's working on.</p>
<p>I'd recommend it if you were new to software shops.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../breaking-asynchronous-loops/">Breaking Asynchronous Loops</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2019-03-08
  </p>
  <p>Suppose you want to iterate over an array. On each element, you want to call a function that takes some callback, and if the callback executes some test successfully, then don't execute the remaining iterations.</p>
<!-- more -->

<p>I needed to examine the elements of an array and try to acquire a lock on the first of them not locked yet. It started as something like this:</p>
<div class="hll"><pre><span></span><span class="kd">function</span> <span class="nx">myFunction</span><span class="p">(</span><span class="nx">myArray</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">el</span> <span class="k">of</span> <span class="nx">myArray</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">acquireResource</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">resource</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Do next iteration.</span>
            <span class="p">}</span>

            <span class="c1">// Resource acquired! Get out of this loop now!</span>
            <span class="k">return</span> <span class="nx">callback</span><span class="p">();</span>
        <span class="p">});</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>For the sake of simplicity, we can imagine the <code>acquireResource</code> function to be pretty silly and just always be successful:</p>
<div class="hll"><pre><span></span><span class="kd">function</span> <span class="nx">acquireResource</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mf">1</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
<p>Would you be surprised if I told you that this loop runs <code>myArray.length</code> times, regardless of us calling the callback sooner or later? Well, I was (apologies). The problem is that the callback is called when the function <code>acquireResource</code> ends, which in Node happens at the end of the for loop when the callbacks are called.</p>
<div class="hll"><pre><span></span><span class="o">&gt;</span> <span class="nx">myFunction</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">4</span><span class="p">],</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="p">...</span>     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;called&#39;</span><span class="p">);</span>
<span class="p">...</span> <span class="p">});</span>
<span class="nx">called</span>
<span class="nx">called</span>
<span class="nx">called</span>
</pre></div>
<p>The solution that I've found is based on recursion. It looks like this:</p>
<div class="hll"><pre><span></span><span class="kd">function</span> <span class="nx">recur</span><span class="p">(</span><span class="nx">anArray</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&gt;=</span> <span class="nx">anArray</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">callback</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="nx">acquireResource</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">resource</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Repeat for the next element!</span>
            <span class="nx">recur</span><span class="p">(</span><span class="nx">anArray</span><span class="p">,</span> <span class="nx">index</span> <span class="o">+</span> <span class="mf">1</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">callback</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">myFunction</span><span class="p">(</span><span class="nx">myArray</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">recur</span><span class="p">(</span><span class="nx">myArray</span><span class="p">,</span> <span class="mf">0</span><span class="p">,</span> <span class="nx">callback</span><span class="p">);</span>    
<span class="p">}</span>
</pre></div>
<p><code>myFunction</code> calls <code>recur</code> with the array and an initial index 0, passing the callback. If the function is called too many times, it means we're used up the array, so we don't need to do anything (the initial check in the <code>recur</code> function). Otherwise, we call recur with the next index. When we're done, we just call the callback, and never go over the other elements in the array. Cool, uh?</p>
<div class="hll"><pre><span></span><span class="o">&gt;</span> <span class="nx">recur</span><span class="p">([</span><span class="mf">1</span><span class="p">,</span> <span class="mf">2</span><span class="p">,</span> <span class="mf">3</span><span class="p">],</span> <span class="mf">0</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="p">{</span>
<span class="p">...</span>     <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;I am called&#39;</span><span class="p">);</span>
<span class="p">...</span> <span class="p">});</span>
<span class="nx">I</span> <span class="nx">am</span> <span class="nx">called</span>
</pre></div>
<p>(Things would probably have been simpler if I were allowed to use async/await, but the function <code>acquireResource</code> was callback-based and so there wasn't much I could do about it.)</p>
<p>Have I missed an obvious error? Do you know a better solution? Leave a comment!</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../briefly-whats-sagemaker/">Briefly, What&#39;s SageMaker?</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2019-01-05
  </p>
  <p>Today I decided to start a new series of short posts that give a high-level basic understanding of some piece of technology. The first post is about AWS SageMaker!</p>
<!-- more -->

<p><a href="https://aws.amazon.com/sagemaker/">SageMaker</a> is part of the Machine Learning solutions provided by Amazon. These solutions are provided in stages:</p>
<h2>Steps for ML using AWS:</h2>
<ol>
<li>Pre-built services to solve standard problems -&gt; Application services (Amazon Rekognition, Polly, Comprehend)</li>
<li>Basic customization (of datasets and algorithms): <em>SageMaker</em></li>
<li>Full control (including infrastructure): EC2 and Deep Learning AMI.</li>
</ol>
<p>To use SageMaker, we only need to write instrumenting code, like tune algorithms and declare where the data is stored.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../forge-your-future-with-open-source-by-vm-vicky-brasseur-610/">Forge Your Future with Open Source, by VM (Vicky) Brasseur (6/10)</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2019-01-05
  </p>
  <p><a href="https://www.librarything.com/work/22561876/">
    <img src="forge-your-future-with-open-source.jpg" width="150" alt="Forge Your Future with Open Source" />
</a></p>
<!-- more -->

<p>I've read this book as a self-help one. I wanted to convince myself that I needed to cut a part of my free time in order to contribute to FOSS (Free and Open Source Software). I didn't need much convincing, neither did I need most of the technical knowledge; in any case, the book doesn't go into much technical detail. What it is good for is in framing the value of contributions in order to advance one's own career.</p>
<p>The take-aways for me were:</p>
<ul>
<li>How and why to compile a list of goals to follow when selecting a project to contribute to</li>
<li>A few legal details:<ul>
<li>Does my company allow me to work on FOSS in my own time on their equipment?</li>
<li>Do I have ideological preferences on which license I demand the project has before a move a finger to contribute to it?</li>
</ul>
</li>
<li>A few organizational ones:<ul>
<li>Look for projects that make it clear how to contribute and facilitate the process for new joiners</li>
<li>The onion structure of FOSS projects</li>
</ul>
</li>
</ul>
<p>The rest of the pages were dull to me. I recommend it as a nice recap of what you need to start contributing. If you know most of the stuff already, you can skip it and get to work instead.</p>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../ive-added-nice-footnotes-to-my-website/">I&#39;ve Added Nice Footnotes to My Website</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2018-12-25
  </p>
  <blockquote class="ancientscroll">
Erm, Bigfoot for some reason stopped working... I've found an alternative and I'll try to fix my poor notes when I find time.
</blockquote><p>I often read <a href="https://jamesclear.com">jamesclear.com</a>, and I really like the way they do footnotes -- they're actually popups that appear when clicking on a button. I wanted to try something similar for this very website and ended up discovering the amazing <code>bigfoot.js</code>.</p>
<!-- more -->

<h2>Solution: hexo + hexo-footnotes + bigfoot</h2>
<p>I was already using <code>hexo-footnotes</code><sup class="footnote-ref" id="fnref-2"><a href="#fn-2">1</a></sup>, a hexo plugin that simplifies writing footnotes. When I want to write one, I do something like:</p>
<div class="hll"><pre><span></span><span class="nx">Hey</span><span class="p">,</span> <span class="k">this</span> <span class="nx">is</span> <span class="nx">a</span> <span class="nx">footnote</span><span class="p">[</span><span class="o">^</span><span class="mf">1</span><span class="p">]</span><span class="o">!</span>
</pre></div>
<p>and then somewhere else I write the content:</p>
<div class="hll"><pre><span></span>[<span class="nl">^1</span>]: <span class="na">This is what you&#39;re going to read following the footnote.</span>
</pre></div>
<p>This generates HTML looking like this:</p>
<div class="hll"><pre><span></span><span class="p">&lt;</span><span class="nt">sup</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;fnref:1&quot;</span><span class="p">&gt;&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;#fn:1&quot;</span> <span class="na">rel</span><span class="o">=</span><span class="s">&quot;footnote&quot;</span><span class="p">&gt;</span>1<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;&lt;/</span><span class="nt">sup</span><span class="p">&gt;</span>
</pre></div>
<p>for the origin, and</p>
<div class="hll"><pre><span></span><span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;footnotes&quot;</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">hr</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;footnotelist&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">ol</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;list-style:none; padding-left: 0;&quot;</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">li</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;fn:1&quot;</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;display: inline-block; vertical-align: top; padding-right: 10px;&quot;</span><span class="p">&gt;</span>1.<span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">span</span> <span class="na">style</span><span class="o">=</span><span class="s">&quot;display: inline-block; vertical-align: top;&quot;</span><span class="p">&gt;</span>
            This is what you&#39;re going to read following the footnote.
            <span class="p">&lt;/</span><span class="nt">span</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;#fnref:1&quot;</span> <span class="na">rev</span><span class="o">=</span><span class="s">&quot;footnote&quot;</span><span class="p">&gt;</span> ↩<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">li</span><span class="p">&gt;</span>
        <span class="p">&lt;/</span><span class="nt">ol</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>
</pre></div>
<p>for the destination.</p>
<p>Now we need to install bigfoot. Here's what I've done, step by step:</p>
<ol>
<li>Downloaded the bundle from the website<sup class="footnote-ref" id="fnref-1"><a href="#fn-1">2</a></sup>, and copied <code>bigfoot.min.js</code> into my theme's directory (<code>themes/landscape/source/js</code>), together with a minified version of jQuery.</li>
<li>Copied <code>bigfoot-default.css</code> into <code>themes/landscape/source/css</code></li>
<li>Added <code>@import "bigfoot.css"</code> at the end of my main style file inside the css directory, <code>style.styl</code></li>
</ol>
<p>Now I just need to write the following snippet in the posts where I want to use it:</p>
<div class="hll"><pre><span></span><span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;/js/jquery-3.3.1.min.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;/js/bigfoot.min.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span> <span class="na">type</span><span class="o">=</span><span class="s">&quot;text/javascript&quot;</span><span class="p">&gt;</span>
    <span class="nx">$</span><span class="p">.</span><span class="nx">bigfoot</span><span class="p">();</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
</pre></div>
<p>and use my footnotes exactly the way I did before.</p>
<h2>Parting thoughts</h2>
<p>You can see examples of the footnotes throughout this post. What I don't really like is that I need to repeat the <code>&lt;script&gt;</code> boilerplate in the files where I want to use bigfoot, and I am sure there's a more elegant and less repetitive way of doing it. Well, I'll leave it for next time for now.</p>
<p>Happy footnoting!</p>
<div class="footnotes">
<hr>
<ol><li id="fn-2"><p>I've also found that the project had out-of-date dependencies, so I created a PR for it. I've got low expectations for it to be merged soon, as the project seems to have been inactive in the last year, and there's no CONTRIBUTING-like file, nor does it seem easy to reach out to the author.<a href="#fnref-2" class="footnote">&#8617;</a></p></li>
<li id="fn-1"><p><a href="http://www.bigfootjs.com/">http://www.bigfootjs.com/</a><a href="#fnref-1" class="footnote">&#8617;</a></p></li>
</ol>
</div>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../i-implemented-a-red-black-tree-part-1/">I Implemented a Red-Black Tree (part 1)</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2018-07-20
  </p>
  <p>A Red-Black tree is a binary search tree (BST) that takes some action to try and keep itself balanced. We know that BSTs are great at storing nodes identified by some key for which an order relationship exists (e.g., integers). They have the property that the values in the left sub-tree of each node <em>n</em> have keys smaller-than <em>n</em>'s key <code>n.k</code>, and those in the right sub-tree have keys greater-than <code>n.k</code><sup class="footnote-ref" id="fnref-1"><a href="#fn-1">1</a></sup>.</p>
<!-- more -->

<p>In a BST, searching for a key takes logarithmic time, if the tree is balanced, that is, if the root's left and right sub-tree have roughly the same height. The problem is that for particular key insertion orders, this might no longer be true: in particular, if you insert the keys in sorted order, you'll find a tree which looks more like a linked list, that makes search linear in the worst case. This is why people have come up with a number of strategies to keep the BST balanced.</p>
<h2>Rotations</h2>
<p>A RB tree changes the <code>Insert</code> and <code>DeleteNode</code> operations by adding a bunch of invariants, to satisfy which some additional work is needed when changing the number of nodes in the tree. The basic operation is the node rotation: there is a way of rotating the position of 2 nodes while keeping the BST relationship valid. Here's a replica of an image from CLRS<sup class="footnote-ref" id="fnref-2"><a href="#fn-2">2</a></sup> to illustrate the procedure: we want to change this</p>
<p><img src="node-rotation.png" width="200" alt="Figure 1. Rotate procedure." /></p>
<p>into this:</p>
<p><img src="node-rotation-after.png" width="200" alt="Figure 2. After rotating right." /></p>
<p>Suppose that the BST properties are valid for the first graph. It is easy to see that they keep holding for the second:</p>
<ul>
<li>The subtree <code>a</code> had keys smaller than <code>x</code> and is still <code>x</code>'s left sub-tree after the rotation</li>
<li>The subtree <code>b</code> had keys larger than <code>x</code>, and is still <code>x</code>'s right sub-tree after the rotation; it was also in <code>y</code>'s sub-tree, and still is after the rotation</li>
<li><code>c</code> remains <code>y</code>'s right sub-tree</li>
</ul>
<p>The tree class starts like:</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">RBTree</span> <span class="p">{</span>
  <span class="c1">// ...</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">root</span><span class="p">;</span> <span class="c1">// Each node keeps a pointer to the tree&#39;s root.</span>
  <span class="kt">int</span> <span class="n">key</span><span class="p">;</span>
  <span class="n">Color</span> <span class="n">color</span><span class="p">;</span>  <span class="c1">// We&#39;ll talk about this later :)</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// The node&#39;s parent.</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
  <span class="c1">// ...</span>
</pre></div>
<p>The code for the rotate-right operation looks like this:</p>
<div class="hll"><pre><span></span><span class="c1">// static</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">RightRotate</span><span class="p">(</span><span class="n">RBTree</span><span class="o">**</span> <span class="n">root</span><span class="p">,</span> <span class="n">RBTree</span><span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>

  <span class="c1">// We&#39;re not in the configuration described in Figure 1, so we just stop.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">x</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
  <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// y is the root:</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>
    <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">y</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// y is a left child: make x its new left child.</span>
    <span class="n">y</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// y is a right child: make x its new right child.</span>
    <span class="n">y</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// x is the new parent of y:</span>
  <span class="n">y</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h2>Test <em>RightRotate</em></h2>
<p>The code above makes just some pointer manipulation to ensure we get in the right layout, as shown in Figure 2. Since we don't have an <code>Insert</code> function yet, we test this by first creating an <code>RBTree</code> object and wiring up the nodes manually. We can build a test fixture in doctest like this:</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">ManualTreeCtor</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="c1">// A full tree of height 3 (7 nodes).</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">a</span><span class="p">;</span>  <span class="c1">// root</span>

  <span class="n">ManualTreeCtor</span><span class="p">()</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">30</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">auto</span><span class="o">*</span> <span class="nf">b</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">18</span><span class="p">));</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="k">auto</span><span class="o">*</span> <span class="nf">c</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">154</span><span class="p">));</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="k">auto</span><span class="o">*</span> <span class="nf">d</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">9</span><span class="p">));</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">d</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="k">auto</span><span class="o">*</span> <span class="nf">e</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">21</span><span class="p">));</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">e</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="k">auto</span><span class="o">*</span> <span class="nf">f</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">84</span><span class="p">));</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
    <span class="n">f</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

    <span class="k">auto</span><span class="o">*</span> <span class="nf">g</span><span class="p">(</span><span class="k">new</span> <span class="n">RBTree</span><span class="p">(</span><span class="mi">192</span><span class="p">));</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">g</span><span class="p">;</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p>which just implements a tree like this:</p>
<p><img src="../../i-implemented-a-red-black-tree-part-1/test-tree.png" alt="Figure 3. Test tree."></p>
<p>We now test the cases for <code>y</code> being the root or not:</p>
<div class="hll"><pre><span></span><span class="n">TEST_CASE_FIXTURE</span><span class="p">(</span><span class="n">ManualTreeCtor</span><span class="p">,</span> <span class="s">&quot;right-rotate non-root&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RBTree</span><span class="o">::</span><span class="n">RightRotate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">30</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">9</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">18</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">21</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST_CASE_FIXTURE</span><span class="p">(</span><span class="n">ManualTreeCtor</span><span class="p">,</span> <span class="s">&quot;right-rotate root without using insert&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RBTree</span><span class="o">::</span><span class="n">RightRotate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">18</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">9</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">30</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">21</span><span class="p">);</span>

    <span class="n">REQUIRE</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="n">CHECK</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">==</span> <span class="mi">154</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>While I won't show the code for the left-rotation, the logic is exactly the same (but for going from the configuration of Fig. 2 to the one in Fig. 1).</p>
<p>With these operations in place, we can now implement the insertion operation.</p>
<h2>Insertion, and the node's color</h2>
<p>RB trees' nodes have an additional attribute: a color which can be either <code>RED</code> or <code>BLACK</code>. It is common to assign some <code>NIL</code> value to all leaves (I implemented it via a nullptr, without an explicit node with that color<sup class="footnote-ref" id="fnref-3"><a href="#fn-3">3</a></sup>). The invariants I mentioned above can be expressed via five properties<a href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">^3</a> :</p>
<ol>
<li>Each node is either red or black.</li>
<li>The root is black.</li>
<li>All leaves (NIL) are black[^3].</li>
<li>If a node is red, then both its children are black.</li>
<li>Every path from a given node to any of its descendant NIL nodes contains the same number of black nodes.</li>
</ol>
<p>These invariants can be kept when inserting. We need to reason about the sibling of the node-to-be-inserted's parent, which we can refer to as the node's <em>uncle</em>. After each insertion, we run an operation <code>InsertFixup</code> to restore the invariants that might have been violated. This is an implementation:</p>
<div class="hll"><pre><span></span><span class="c1">// static</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">Insert</span><span class="p">(</span><span class="n">RBTree</span><span class="o">**</span> <span class="n">root</span><span class="p">,</span> <span class="n">RBTree</span><span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

  <span class="n">RBTree</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">RBTree</span><span class="o">*</span> <span class="n">x</span> <span class="o">=</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">y</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">y</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">z</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">z</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
  <span class="n">z</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">;</span>
  <span class="n">InsertFixup</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>The <code>InsertFixup</code> method for node <em>z</em> is a bit messy because there are many checks for null pointers, but the two branches of the <code>if</code> statement do very symmetric operations (inverting left and right), and the branch selected depends on <em>z</em>'s parent being a left or right child.</p>
<div class="hll"><pre><span></span><span class="c1">// static</span>
<span class="kt">void</span> <span class="n">RBTree</span><span class="o">::</span><span class="n">InsertFixup</span><span class="p">(</span><span class="n">RBTree</span><span class="o">**</span> <span class="n">root</span><span class="p">,</span> <span class="n">RBTree</span><span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">root</span><span class="p">);</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">z</span> <span class="o">&amp;&amp;</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">&amp;&amp;</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">==</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// z&#39;s parent is a left child. Its uncle is z&#39;s parent right child.</span>
      <span class="k">auto</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Case 1: z&#39;s uncle is red.</span>
        <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
        <span class="n">y</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
        <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">;</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>        
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Case 2: z&#39;s uncle is black and z is a right child.</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
        <span class="n">RBTree</span><span class="o">::</span><span class="n">LeftRotate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>           
      <span class="p">}</span>

      <span class="c1">// Case 3: z&#39;s uncle is black and z is a left child.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&amp;&amp;</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">;</span>
          <span class="n">RBTree</span><span class="o">::</span><span class="n">RightRotate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">==</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span><span class="o">*</span> <span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
          <span class="n">y</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
          <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">;</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">==</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
          <span class="n">RBTree</span><span class="o">::</span><span class="n">RightRotate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">z</span> <span class="o">&amp;&amp;</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>            
            <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">RED</span><span class="p">;</span>
            <span class="n">RBTree</span><span class="o">::</span><span class="n">LeftRotate</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">z</span><span class="o">-&gt;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="p">(</span><span class="o">*</span><span class="n">root</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">Color</span><span class="o">::</span><span class="n">BLACK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<h2>Conclusion</h2>
<p>I've said a few words about Red-Black trees, a kind of binary search trees that have the property of remaining balanced when inserting and deleting nodes. In this post, I've shown the basic <code>rotate</code> operation and shown an implementation of <code>Insert</code>. In the next episodes, I'll implement a <code>DeleteNode</code> operation, and then benchmark the tree against a classic binary search tree to see how much my implementation keeps its promises.</p>
<div class="footnotes">
<hr>
<ol><li id="fn-1"><p>I am somehow simplifying by not counting the keys equal to <code>n.k</code>. However, that is a small issue for which I've tried a couple of easy solutions, like either relaxing the constraint on either sub-tree (e.g., smaller-than-or-equal rather than smaller-than for the left sub-tree), or using a counter in each node for repeated keys. It's the typical tiny implementation detail algorithm courses tend to skip over.<a href="#fnref-1" class="footnote">&#8617;</a></p></li>
<li id="fn-2"><p><a href="https://en.wikipedia.org/wiki/Introduction_to_Algorithms">https://en.wikipedia.org/wiki/Introduction_to_Algorithms</a><a href="#fnref-2" class="footnote">&#8617;</a></p></li>
<li id="fn-3"><p>I haven't found this decision to limit the implementation of <code>Insert</code>, but I might revisit it when I'll finally understand what it's for. In particular, I plan to use a single node with no value and only the color black, which all other leaves will point to.<a href="#fnref-3" class="footnote">&#8617;</a></p></li>
</ol>
</div>

  </div>

  
    
  <div class="blog-post">
  
    <h2><a href="../../implement-stdmultiset/">Implement std::multiset</a></h2>
  
  <p class="meta">
    written by
    
      <a href="https://twitter.com/increatore">Gian</a>
    
    on 2018-07-12
  </p>
  <p>In this post, I talk about the <code>std::multiset</code> and about some design decisions I needed when trying to implement it. The full implementation is on <a href="https://github.com/sturmer/reference-implementations-cpp/tree/master/DataStructures/multiset">GitHub</a>.</p>
<!-- more -->

<h1>Multisets and multimaps</h1>
<p>There are a few data structures in the standard library that I never use. In some cases, it's because I never had the right use case no my hands, in others (embarrassingly enough) because I am too lazy to read up about one that I'm not already familiar with. But lately I've found myself needing something to solve a problem, and I discovered that I could get some great help by just using a data structure I'd never heard of: the <code>std::multiset</code> (or its cousin, the <code>std::multimap</code>).</p>
<p>I had read about it before. On the surface, it is just like a <code>std::set</code>, but it let you store the keys multiple times. Why on Earth would you need that, and in particular, which cases are not served as well by just the <code>std::set</code>?</p>
<p>There's something interesting, however, about this structure: It keeps its keys sorted. Consider the following situation: You want to store the nodes of a binary tree by level (root being at level 1, leaves at <code>level O(log(N)) + 1</code> if we have <code>N</code> nodes and a balanced tree). Then you want to print the sum of the values of the nodes at each level, sorted by (ascending) level.</p>
<p>You could scan the tree and use a map level-to-nodes to accomplish this. However, you know that a <code>std::map</code> would not keep the order of the keys.</p>
<p>A better way to do it is by using a multimap! You'd do something like:</p>
<div class="hll"><pre><span></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">level_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
    <span class="n">node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">printLevelSums</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">num_levels</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">multimap</span><span class="o">&lt;</span><span class="n">level_t</span><span class="p">,</span> <span class="n">node</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>

    <span class="c1">// Store each node using the level as a key. Note that we have multiple</span>
    <span class="c1">// keys with the same value.</span>
    <span class="c1">// ...</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_levels</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">range</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">equal_range</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">range</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h1>Implementing a multiset</h1>
<p>The requirements on the basic operations of a multiset, expressed in terms of time complexity, are the following:</p>
<div class="hll"><pre><span></span><span class="c1">// O(log(size)):</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span>  
<span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">);</span>

<span class="c1">// Returns the number of elements with key `key`.</span>
<span class="c1">// O(log(size of the container)) plus linear in the number of the elements</span>
<span class="c1">// found.</span>
<span class="kt">unsigned</span> <span class="nf">count</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// Removes all elements with the key equivalent to key. Return number of</span>
<span class="c1">// elements erased. O(log(c.size()) + c.count(k)).</span>
<span class="kt">unsigned</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">);</span>
</pre></div>
<p>We see that the insertion and search are not constant like they would if using a hash, but logarithmic. The <code>count</code> operation reveals how many elements having the same key are in the multiset.</p>
<p>One way of implementing this is by using a <a href="https://en.wikipedia.org/wiki/Binary_search_tree">binary search tree</a>, where each node contains a <code>vector&lt;Key&gt;</code>. We would then have something like:</p>
<div class="hll"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Key</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">multiset</span> <span class="p">{</span>
    <span class="k">typedef</span> <span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span> <span class="n">BinarySearchTree</span><span class="p">;</span>
    <span class="n">BinarySearchTree</span> <span class="n">backend_</span><span class="p">;</span>

    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
<h2>Back-end: the <code>node</code></h2>
<p>The strategy I used was to just implement a BST with the right data and then forwarding the operations to the node. You all know what a node/BST looks like, so I'll just write a few words about bizarre operations I implemented. Here's the complete interface of the node/BST structure (I decided to use the node as a recursive definition of a BST):</p>
<div class="hll"><pre><span></span><span class="c1">// A node is a tree.</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Key</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="nc">node</span> <span class="p">{</span>
   <span class="k">private</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">data_</span><span class="p">;</span>  <span class="c1">// never null if the object exists.    // TODO:</span>
                         <span class="c1">// use optional&lt;vector&lt;Key&gt;&gt;</span>

    <span class="kt">void</span> <span class="nf">getsize</span><span class="p">(</span><span class="kt">unsigned</span><span class="o">&amp;</span> <span class="n">cnt</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">vectorize</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">*&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span><span class="p">,</span> <span class="n">is_left_child_t</span><span class="o">&gt;</span> <span class="n">findParent</span><span class="p">(</span><span class="k">const</span> <span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">n</span><span class="p">);</span>

   <span class="k">public</span><span class="o">:</span>
    <span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">left_</span><span class="p">;</span>
    <span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">right_</span><span class="p">;</span>

    <span class="n">node</span><span class="p">()</span> <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">left_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">node</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">data_</span><span class="p">(</span><span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;</span><span class="p">),</span> <span class="n">left_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">),</span> <span class="n">right_</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">data_</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">node</span><span class="p">();</span>

    <span class="n">Key</span> <span class="nf">value</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
    <span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="nf">contains</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="nf">count</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="nf">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="nf">nodesize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">findSuccessor</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">Key</span><span class="o">&amp;</span> <span class="n">k</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">*&gt;</span> <span class="n">vectorize</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<ul>
<li><code>vectorize</code>: this method transforms the multiset into a vector of the keys, without repeating them. It is useful for the implementation of the <code>iterator</code>. I'll talk about the iterators in a separate section.</li>
<li><code>nodesize</code>: The number of items associated with a single <code>Key</code>. <code>size</code> just returns the number of stored keys.</li>
<li><code>findParent</code>: I don't store the node's parent in my implementation. It would have simplified things, but it's a trade-off between space and complexity, or space and time (I need to find the parent when I need it, which takes <code>O(log(N))</code> time, so I can spare a pointer in each node, that would allow me to find the parent in <code>O(1)</code> if I know the address of the node in question. Oh well.)</li>
</ul>
<h3>Iterators</h3>
<p>The iterator on a multiset should offer what you usually expect from such a class: a <code>begin()</code> and an <code>end()</code> method, plus some pre- and post-increment or another equivalent of a <code>next()</code> method to go to the next node. To do it, I've used a <code>vector</code> of Key pointers and an index into it. When I build an iterator from a node, I can process the sub-tree starting at that node. Since the multiset contains only Key values, my iterator needs to hide the fact that I'm using a tree in the back-end, which is why the de-referencing operator returns a Key itself, and not a node.</p>
<div class="hll"><pre><span></span><span class="k">class</span> <span class="nc">iterator</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">*&gt;</span> <span class="n">to_process_</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cur_</span><span class="p">;</span>

       <span class="k">public</span><span class="o">:</span>
        <span class="n">iterator</span><span class="p">(</span><span class="n">node</span><span class="o">&lt;</span><span class="n">Key</span><span class="o">&gt;*</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span> <span class="n">cur_</span><span class="p">(</span><span class="n">n</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">to_process_</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">vectorize</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// pre-increment:</span>
        <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur_</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="o">++</span><span class="n">cur_</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur_</span> <span class="o">==</span> <span class="n">to_process_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">cur_</span> <span class="o">=</span> <span class="mi">-1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Key</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur_</span> <span class="o">==</span> <span class="mi">-1</span> <span class="o">||</span> <span class="n">cur_</span> <span class="o">==</span> <span class="n">to_process_</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="nf">OutOfRange</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="o">*</span><span class="n">to_process_</span><span class="p">[</span><span class="n">cur_</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur_</span> <span class="o">==</span> <span class="mi">-1</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="p">.</span><span class="n">cur_</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">cur_</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur_</span> <span class="o">&gt;=</span> <span class="n">to_process_</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span> <span class="n">cur_</span> <span class="o">==</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">to_process_</span><span class="p">[</span><span class="n">cur_</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">it</span><span class="p">.</span><span class="n">to_process_</span><span class="p">[</span><span class="n">cur_</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">to_process_</span><span class="p">[</span><span class="n">cur_</span><span class="p">])</span> <span class="o">==</span> <span class="o">*</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">to_process_</span><span class="p">[</span><span class="n">cur_</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">iterator</span><span class="o">&amp;</span> <span class="n">it</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">it</span><span class="p">);</span> <span class="p">}</span>

    <span class="p">};</span>
</pre></div>
<h1>Conclusions</h1>
<p>A few considerations:</p>
<p>Needless to say, there's a lot of room for improvement. It took me a few days to implement this basic version, and I realize now that it might not necessarily do what I wanted to do (for instance, the iterator doesn't allow you to iterate over all the keys, like the <code>std::multiset</code> does, but only on the non-repeating ones).</p>
<p>Once more, I see that implementing on paper to have a full vision of what you're going to do is of paramount importance: The farther down the way to the full implementation you spot errors, the longer the corrections take, and the more they can impact other areas which you have lost track of in the meanwhile. With more experience, you can usually keep a bigger plan in your head.</p>

  </div>

  

  
  <div class="pagination">
    
      <a href="../../">&laquo; Previous</a>
    
    | 2 |
    
      <a href="../3/">Next &raquo;</a>
    
  </div>


  </div>
  <footer>
    &copy; Copyright 2021 by Gianluca Ciccarelli.
  </footer>
</body>
